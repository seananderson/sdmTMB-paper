---
title: "Appendix 5: example of index standardization of fishery-independent survey data with VAST"
output:
  pdf_document:
    highlight: tango
---

```{r setup, include = FALSE, cache=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.asp = 0.618,
  cache = TRUE,
  autodep = TRUE,
  cache.comments = FALSE
)
```

```{r packages, message = FALSE, warning = FALSE, cache = FALSE}
library(TMB)
library(VAST)
library(sp)
library(sdmTMB)
library(here)
```

We will fit a geostatistical spatiotemporal model with VAST for the purposes of index standardization, following the sdmTMB example. We will use a data set built into the sdmTMB package: trawl survey data for Pacific Cod in Queen Charlotte Sound. The density units are kg/km^2^. Here, X and Y are coordinates in UTM zone 9.

To specify the mesh used to approximate the spatial process, which is used in the SPDE calculations, we use the k-means method in VAST. Rather than specifying the cutoff distance, meshes in VAST are typically generated by specifying only the number of knots, which we will later pass, along with other model settings to the function make_settings. We will use 205 knots, the same number in the mesh created in the other versions of this appendix.

For this example, we will include a factor predictor that represents the mean estimate for each time slice. Settings used for index standardization are specified partially by defining `purpose = "index2"` but we also explicitly provide arguments for these and other key settings here. Specifically, we set the elements of `RhoConfig` to 0 to specify that we want the intercepts and spatiotemporal fields to be independent (which is the default). 

VAST is constructed to accommodate many different model structures, including delta or hurdle models, and thus requires the user to specify arguments for the spatial and spatiotemporal fields of two model components. In this case, we want to fit a model with a single component, using the Tweedie distribution. To do so, we must turn off estimation of omega and epsilon for 1st linear predictor by entering 0 for those elements in the object we'll use to define the configuration of these fields `FieldConfig`.
 
```{r config, echo = TRUE}
FieldConfig <- matrix(c("0", "0", "IID", "Identity", "IID", "IID", "IID", "Identity"),
  ncol = 2, nrow = 4,
  dimnames = list(
    c("Omega", "Epsilon", "Beta", "Epsilon_year"),
    c("Component_1", "Component_2")
  )
)
FieldConfig

RhoConfig <- c("Beta1" = 3, "Beta2" = 0, "Epsilon1" = 0, "Epsilon2" = 0)
```

Unlike in sdmTMB, the fitting and predicting steps are all accomplished with the function 'fit_model' and thus we need to specify the prediction grid (referred to as the "extrapolation grid" in VAST).  Several options are built in, for commonly-used regions, but in this example we'll need to format the Queen Charlotte Sound grid in sdmTMB to be used in VAST and specify `Region = "User"` in make_setting and `"input_grid" = input_grid` in `fit_model()`.


```{r settings, echo = TRUE}
# get coordinates in geographic coordinates from UTM projection, after changing units to m
qcs_grid_ll <- qcs_grid
qcs_grid_ll$Y <- qcs_grid_ll$Y * 1000
qcs_grid_ll$X <- qcs_grid_ll$X * 1000

# with sp:
coordinates(qcs_grid_ll) <- ~ X + Y
proj4string(qcs_grid_ll) <- CRS("+proj=utm +zone=9")
qcs_grid_ll <- as.data.frame(spTransform(qcs_grid_ll, CRS("+proj=longlat +datum=WGS84")))

# or with sf:
# qcs_grid_ll <- sf::st_as_sf(
#   x = qcs_grid_ll,
#   coords = c("X", "Y"),
#   crs = "+proj=utm +zone=9"
# )
# qcs_grid_ll <- sf::st_transform(qcs_grid_ll, crs = "+proj=longlat +datum=WGS84")

# remove replicate locations for each year and format for VAST
qcs_grid_ll <- subset(qcs_grid_ll, year == min(qcs_grid_ll$year))
input_grid <- cbind(Lat = qcs_grid_ll$Y, Lon = qcs_grid_ll$X, Area_km2 = 4)

settings <- make_settings(
  n_x = 205, # number of vertices in the SPDE mesh
  Region = "User",
  purpose = "index2", # use recommended defaults for an index of abundance
  fine_scale = TRUE, # use bilinear interpolation from the INLA 'A' matrix
  zone = 9,
  FieldConfig = FieldConfig,
  RhoConfig = RhoConfig,
  ObsModel = c(10, 2), # use the Tweedie distribution as the observation model
  bias.correct = FALSE,
  use_anisotropy = FALSE,
  max_cells = Inf, # use all grid cells from the extrapolation grid
  knot_method = "grid" # or "samples"
)
```

Next we will fit a GLMM (generalized linear mixed effects model).

```{r fit, echo = TRUE, results = FALSE, message = FALSE, warning = FALSE}
 # create folder for saved output:
dir.create(paste0(here("doc", "appendix-VAST-tweedie")), showWarnings = FALSE)

# effort is 1 when using CPUE instead of observed weight as the response:
pcod$effort <- 1
pcod <- as.data.frame(pcod) # ensure not a tibble
f <- here("doc", "appendix-VAST-tweedie", "vast-cache.rds")
if (!file.exists(f)) {
  tictoc::tic()
  fit <- fit_model(
    settings = settings,
    Lat_i = pcod[, "lat"],
    Lon_i = pcod[, "lon"],
    t_i = pcod[, "year"],
    b_i = pcod[, "density"],
    a_i = pcod[, "effort"],
    input_grid = input_grid,
    working_dir = paste0(here("doc", "appendix-VAST-tweedie"), "/")
  )
  tictoc::toc()
  saveRDS(fit, file = f)
} else {
  fit <- readRDS(f)
}
```

We can look at parameter estimates and their standard errors.

```{r check-parameters, echo = TRUE}
fit$parameter_estimates$SD
```

Fit sdmTMB model and compare:

```{r sdmTMB-example, echo = TRUE, cache=TRUE}
mesh <- make_mesh(pcod, xy_cols = c("X", "Y"),
  mesh = fit$spatial_list$MeshList$isotropic_mesh)
tictoc::tic()
fit_sdmTMB <- sdmTMB(density ~ 0 + as.factor(year), 
  data = pcod, mesh = mesh, family = tweedie(link = "log"),
  time = "year", spatiotemporal = "iid", spatial = "on")
tictoc::toc()

s1 <- fit$ParHat$beta1_ft[fit$ParHat$beta2_ft != 0]
s2 <- fit$ParHat$beta2_ft[fit$ParHat$beta2_ft != 0]
b_VAST <- as.numeric(s1 + s2)

b_sdmTMB <- tidy(fit_sdmTMB)

plot(b_sdmTMB$estimate, b_VAST);abline(0, 1)
cor(b_sdmTMB$estimate, b_VAST)

s <- fit$parameter_estimates$SD
vast_est1 <- as.list(s, "Estimate", report = FALSE)
vast_est2 <- as.list(s, "Estimate", report = TRUE)
vast_sd1 <- as.list(s, "Std. Error", report = FALSE)
vast_sd2 <- as.list(s, "Std. Error", report = TRUE)

sdmtmb_est <- tidy(fit_sdmTMB, "ran_pars")

# range
sdmtmb_est$estimate[sdmtmb_est$term == "range"]
vast_est2$Range_raw2

# sigma_O
sdmtmb_est$estimate[sdmtmb_est$term == "sigma_O"]
vast_est1$L_omega2_z

# sigma_E
sdmtmb_est$estimate[sdmtmb_est$term == "sigma_E"]
vast_est1$L_epsilon2_z

# Tweedie p
sdmtmb_est$estimate[sdmtmb_est$term == "tweedie_p"]
1 + plogis(fit$ParHat$logSigmaM[1,1] )

# Tweedie dispersion
as.numeric(exp(fit$ParHat$beta1_ft))[1]
sdmtmb_est$estimate[sdmtmb_est$term == "phi"]
```

While making custom plots of individual elements requires a fair bit of work to extract and reformat the necessary components of each output, VAST has a wrapper function that generates the typical plots one may want. While here we stick with the default set of plots, where `plot_set = 3`, one can specify different standard plots to make by changing the setting of this argument (see `?FishStatsUtils::plot_maps`).

```{r save-plots, echo = TRUE, message = FALSE, warning = FALSE}
if (!file.exists(here("doc", "appendix-VAST-tweedie", "Data_and_knots.png")) {
  plot(
    fit,
    check_residuals = FALSE,
    working_dir = paste0(here("doc", "appendix-VAST-tweedie"), "/")
  )
}
```

The saved plots can be perused by browsing the exported image files in the working directory, but here we will read in some key plots as an example. We can start by looking at the location of samples and knots.

```{r plot-knots, echo = TRUE, out.width = "6in"}
knitr::include_graphics(here("doc", "appendix-VAST-tweedie", "Data_and_knots.png"))
```

Then we can look at maps of the predicted population densities (here on the log scale).

```{r plot-density, echo = TRUE, out.width = "6in"}
knitr::include_graphics(here("doc", "appendix-VAST-tweedie", "ln_density-predicted.png"))
```

And finally the biomass index.

```{r plot-index, echo = TRUE, out.width = "3in"}
if (file.exists(here("doc", "appendix-VAST-tweedie", "Index-Biomass.png"))) {
  knitr::include_graphics(here("doc", "appendix-VAST-tweedie", "Index-Biomass.png"))
}
if (file.exists(here("doc", "appendix-VAST-tweedie", "Index.png"))) {
  knitr::include_graphics(here("doc", "appendix-VAST-tweedie", "Index.png"))
}
```

We can compare the index we would get using sdmTMB. Since sdmTMB does not have built-in delta models, we need some way of combining the predictions across the two models. Here, we will do that by simulating from the joint parameter precision matrix and calculating the index with those draws. This should be approximately comparable with the bias-corrected index calculated above with VAST.

```{r sdmTMB-index, cache=TRUE, echo=TRUE}
pred <- predict(fit_sdmTMB, newdata = qcs_grid, return_tmb_object = TRUE, area = 4)
ind_sdmTMB <- get_index(pred)
```

Now, we can compare the indices. We will read in the VAST index from the `Index.csv` file created by the `plot.fit_model()` method above.

```{r index-compare, message=FALSE, warning=FALSE}
library(dplyr)
library(ggplot2)
vast_i <- read.csv(here("doc/appendix-VAST/Index.csv")) %>%
  mutate(index = "VAST", year = as.numeric(Time), est = Estimate, 
    se = Std..Error.for.ln.Estimate.) %>% 
  select(index, year, est, se) %>% 
  mutate(lwr = exp(log(est) + qnorm(0.025) * se)) %>% 
  mutate(upr = exp(log(est) + qnorm(0.975) * se))
sdm_i <- ind_sdmTMB %>% mutate(index = "sdmTMB")
both_i <- bind_rows(sdm_i, vast_i) %>% filter(est > 0)
ggplot(both_i, aes(x = year, y = est, ymin = lwr, ymax = upr, colour = index)) + 
  geom_ribbon(alpha = 0.3) +
  geom_line() + 
  ylim(0, max(both_i$upr)) +
  coord_cartesian(expand = FALSE) +
  ylab("Biomass (t)")
```

This document was built using:

```{r, echo=TRUE}
R.Version()$version.string
packageVersion("VAST")
packageVersion("FishStatsUtils")
```

