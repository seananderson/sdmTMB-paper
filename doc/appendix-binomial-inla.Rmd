---
title: "Appendix 4: species distribution model comparison between inla and sdmTMB"
output:
  pdf_document:
    highlight: tango
---

```{r setup, include = FALSE, cache=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.asp = 0.618,
  cache = TRUE,
  autodep = TRUE
)
```


```{r packages, message=FALSE, warning=FALSE, cache=FALSE}
library(ggplot2)
library(dplyr)
library(sdmTMB)
library(INLA)
library(inlabru)
theme_set(ggsidekick::theme_sleek())
```

In this example, we fit a presence-absence species distribution model with fixed effect intercepts for year and spatiotemporal random fields using AR1. 
This will be fit with a binomial distribution and a logit link. 
Once again we will use a data set built into the package: trawl survey data for Pacific Cod in Queen Charlotte Sound.
INLA requires sequentially numbered time steps, we start by selecting the years we will include in this model and creating the year index variable `i_year`.

```{r}
d <- pcod %>% filter(year >= 2011)
yr_lu <- data.frame(year = unique(d$year), i_year = seq_along(unique(d$year)))
d <- dplyr::left_join(d, yr_lu)
```

In this example, we will use identical priors for the range and random field SD (aka. sigma) for models built in INLA and with sdmTMB.
While being described different in each package, the numbers amount to the probability the range is below a lower limit (e.g., `P(range < 5) = 0.05`) and that the sigma is above an upper limit (e.g., `P(sigma > 5) = 0.05`).

```{r set-priors, echo = TRUE, cache=FALSE}
range_min <- 5
range_prob <- 0.05
sigma_max <- 5
sigma_prob <- 0.05
```

In INLA a PC-prior can be used for the temporal autoregressive parameter, i.e., the which defines the probability the autocorrelation parameter is greater than a given value (e.g., `P(cor > 0) = 0.9`), but for now sdmTMB only takes a mean and SD (e.g., `ar1_rho = normal(0, 1)`) so we will not set a prior for either model.

```{r}
h.spec <- list(rho = list(prior = 'pccor1', param = c(0, 0.9)))
```

We will start by building an identical meshes using both sdmTMB and INLA.
Here, X and Y are coordinates in UTM zone 9.
These same functions that are used internally in the sdmTMB `make_mesh()` function. 

```{r sdm-mesh, echo = TRUE, cache=FALSE}
sdm_mesh <- make_mesh(d, xy_cols = c("X", "Y"), cutoff = 10)
```

```{r inla-mesh, echo = TRUE, cache=FALSE}
loc_xy <- as.matrix(d[, c("X", "Y"), drop = FALSE])
inla_mesh <- INLA::inla.mesh.create(loc_xy, refine = TRUE, cutoff = 10)

spde <- inla.spde2.pcmatern(
  mesh = inla_mesh, # an smdTMB mesh can be inserted here with sdm_mesh$mesh
    prior.range = c(range_min, range_prob),
    prior.sigma = c(sigma_max, sigma_prob)) 
```

```{r plot-inla-mesh, fig.asp=0.9, out.height="3in"}
plot(sdm_mesh);title(main = "sdmTMB mesh");plot(spde$mesh)
```


# INLA 

Data preparation for INLA models includes a formulae, as well as objects made using several different functions including: `inla.spde.make.index()`, `inla.spde.make.A()`, and `inla.stack()`.
TODO: explain further, including `control.inla = list(int.strategy = "eb", strategy = "gaussian")` 
TODO: We use very weak priors on the fixed effects (`mean = 0, prec = 1/(100*100)`)?


```{r inla}
tictoc::tic("INLA")

nyear <- length(unique(d$year))

iset <- inla.spde.make.index('i', n.spde = spde$n.spde, n.group = nyear)

A <- inla.spde.make.A(mesh = inla_mesh, loc = loc_xy, group = d$i_year)

sdat <- inla.stack(
  data = list(y = d$present),
  A = list(A, 1),
  effects = list(iset, year_factor = as.factor(d$year)),
  tag = 'stdata')

formulae <- y ~ 0 + year_factor + f(i, model = spde, group = i.group,
  control.group = list(model = 'ar1'))
  # control.group = list(model = 'ar1', hyper = h.spec))

m_inla <- inla(formulae,
  data = inla.stack.data(sdat),
  control.predictor = list(compute = TRUE, A = inla.stack.A(sdat)),
  family = "binomial",
  control.family = list(link = "logit"),
  control.fixed = list(expand.factor.strategy = 'inla', mean = 0, prec = 1/(100*100)),
  verbose = FALSE,
  control.inla = list(int.strategy = "eb", strategy = "gaussian"),
  control.compute = list(config = TRUE)
  )

tictoc::toc()

summary(m_inla)
# saves fixed effect coefs
inla_coefs <- m_inla$summary.fixed[, c("mean", "sd")]
```

<!-- # inlabru -->

<!-- *** NOT WORKING YET *** -->

<!-- There are a couple ways to include the fixed effects with `inlabru`. Unfortunately, using factor variables in the standard equation syntax does not work. In the first case, we can create a design matrix and add year effects individually to the formula. -->


<!-- Now we can set up the design matrix for `inlabru`   -->

<!-- ```{r echo = F} -->
<!-- m <- lm(present ~ -1 + as.factor(year), data = d) -->
<!-- model_mat <- model.matrix(m) -->
<!-- colnames(model_mat) <- paste0("x", unique(d$year)) -->
<!-- dat <- cbind(d, model_mat) %>% mutate(x = X, y = Y) -->

<!-- # dat <- dat %>% sf::st_as_sf(coords = c("x", "y")) -->

<!-- coordinates(dat) <- c("x", "y") -->
<!-- dat <- as(dat, "SpatialPointsDataFrame") -->
<!-- ``` -->

<!-- Next we set up the `components` object for the model. This includes a formula with fixed or random effects (here only fixed) and the design of the spatial random field. The name `spatrf` can be anything, but includes the coordinates, spde model, and how the year effects are shared.  -->

<!-- ```{r eval = F, echo = F} -->
<!-- components <- present ~ 0 +  -->
<!--     x2009 + x2011 + x2013 + x2015 + x2017  +  -->
<!--     # x2009(main=x2009, model="linear") + -->
<!--     # x2011(main=x2011, model="linear") + -->
<!--     # x2013(main=x2013, model="linear") + -->
<!--     # x2015(main=x2015, model="linear") + -->
<!--     # x2017(main=x2017, model="linear") + -->
<!--     spatrf(coordinates, model = spde, group = year, ngroup=length(unique(d$year)), -->
<!--       control.group = list(model = 'ar1', hyper = h.spec)) -->

<!-- m_bru <- bru( -->
<!--   components = components, -->
<!--   family = "binomial", -->
<!--   options =  -->
<!--    list(bru_verbose = TRUE,  -->
<!--         control.fixed = list(expand.factor.strategy = 'inla'), -->
<!--         control.family = list(link = "logit"), -->
<!--         control.inla = list(int.strategy = "eb", strategy = "gaussian"), -->
<!--         control.compute = list(config = TRUE) -->
<!--   ), -->
<!--   data = dat -->
<!-- ) -->

<!-- bru_coefs <- m_bru$summary.fixed[, c("mean", "sd")] -->
<!-- summary(m_bru) -->
<!-- ``` -->


<!-- The other way to set up the fixed coefficients with `inlabru` is to use the `fac` argument. Note the location of the parameters changes from to `summary.random$fac` -->

<!-- ```{r } -->
<!-- tictoc::tic("bru") -->

<!-- components <- present ~ 0 + -->
<!--   spatrf(main = coordinates, model = spde, group = dat$year, ngroup=length(unique(dat$year)), -->
<!--       control.group = list(model = 'ar1')) + -->
<!--       # control.group = list(model = 'ar1', hyper = h.spec)) + -->
<!--   # fac(main = year,  model = "iid", -->
<!--   #     hyper = list(prec = list(initial = log(1e-6), -->
<!--   #                            fixed = TRUE)) -->
<!--   # ) -->
<!--   fac(main = year,  model = "factor_full") -->

<!-- m_bru <- bru( -->
<!--   components = components, -->
<!--   family = "binomial", -->
<!--   options =  -->
<!--    list(bru_verbose = TRUE,  -->
<!--         control.fixed = list(expand.factor.strategy = 'inla'), -->
<!--         control.family = list(link = "logit"), -->
<!--         control.inla = list(int.strategy = "eb", strategy = "gaussian"), -->
<!--         control.compute = list(config = TRUE) -->
<!--   ), -->
<!--   data = dat -->
<!-- ) -->
<!-- tictoc::toc() -->

<!-- bru_coefs <- m_bru$summary.random$fac[, c("mean", "sd")] -->
<!-- summary(m_bru) -->
<!-- ``` -->


<!-- ```{r} -->
<!-- m_bru <- bru_rerun(m_bru, options = list()) -->
<!-- summary(m_bru) -->
<!-- ``` -->


<!-- Comparing the spatial random effects between `INLA` and `inlabru` shows us that the latter is not estimating well. -->

<!-- ```{r} -->
<!-- m_inla$summary.hyperpar[, c("mean", "sd")] -->
<!-- m_bru$summary.hyperpar[, c("mean", "sd")] -->
<!-- ``` -->

<!-- As a result the fixed effect estimates are also quite different.  -->

<!-- ```{r} -->
<!-- plot(inla_coefs$mean, bru_coefs$mean) -->
<!-- abline(a = 0, b = 1) -->
<!-- ``` -->


# sdmTMB

We then fit a very similar model with `sdmTMB()`. 
We again use very weak priors on the fixed effects.

```{r sdmtmb, warning=FALSE, message=FALSE}
tictoc::tic("sdmTMB")

m <- sdmTMB(present ~ 0 + as.factor(year), 
  data = d, 
  mesh = sdm_mesh, 
  time = "year",
  spatial = "off", 
  spatiotemporal = "AR1", 
  family = binomial(link = "logit"),
  priors = sdmTMBpriors(
    matern_st = pc_matern(
      range_gt = range_min, range_prob = range_prob, #P(range > 5) = 1-0.05
      sigma_lt = sigma_max, sigma_prob = sigma_prob #P(sigma < 5) = 1-0.05
    ),
    b = normal(0, 100)
  ))

tictoc::toc()
summary(m)
tidy(m, "ran_pars", conf.int = TRUE)
# saves fixed effect coefs
sdmtmb_coefs <- tidy(m, effects = "fixed")
```

# Comparison

Comparing the fixed effects between `sdmTMB` and `inla` shows the estimates are very tightly correlated.  

```{r , out.width="4in"}
plot(sdmtmb_coefs$estimate, inla_coefs$mean)
abline(a = 0, b = 1)
```


With sdmTMB, we can extract parameter simulations from the joint precision matrix using `spread_sims()` or `gather_sims()` functions.

```{r sdm-sims}
post_sdmTMB <- gather_sims(m, n_sims = 2000L)

post_sdmTMB2 <- post_sdmTMB %>% mutate(variable = factor(`.variable`, 
                    levels = unique(post_sdmTMB$`.variable`), 
                    labels = c( "2011", "2013", "2015", "2017", 
                                "Range", "AR1 rho", "Random Field SD")))
```


We then compare the distribution of these sdmTMB simulations to the marginal posterior densities from INLA. 
From INLA, we can extract the marginal posterior densities using `inla.smarginal()` and name them to match the variable names from the sdmTMB `gather_sims()` function.
TODO: maybe say something about why not using `inla.posterior.sample(result = m_inla, n = 400L)`?

```{r inla-densities}
# post_inla <- inla.posterior.sample(result = m_inla, n = 400L)
x <- list()
x[[1]] <- inla.smarginal(m_inla$marginals.fixed$year_factor2011) %>% as_tibble() %>% 
  mutate(variable = "as.factor.year.2011") 
x[[2]] <- inla.smarginal(m_inla$marginals.fixed$year_factor2013) %>% as_tibble() %>% 
  mutate(variable = "as.factor.year.2013") 
x[[3]] <- inla.smarginal(m_inla$marginals.fixed$year_factor2015) %>% as_tibble() %>% 
  mutate(variable = "as.factor.year.2015") 
x[[4]] <- inla.smarginal(m_inla$marginals.fixed$year_factor2017) %>% as_tibble() %>% 
  mutate(variable = "as.factor.year.2017") 
x[[5]] <- inla.smarginal(m_inla$marginals.hyperpar$`Range for i`) %>% as_tibble() %>% 
  mutate(variable = "range") 
x[[6]] <- inla.smarginal(m_inla$marginals.hyperpar$`Stdev for i`) %>% as_tibble() %>% 
  mutate(variable = "sigma_E") 
x[[7]] <- inla.smarginal(m_inla$marginals.hyperpar$`GroupRho for i`) %>% as_tibble() %>% 
  mutate(variable = "ar1_rho") 
post_inla1 <- do.call(rbind, x)

post_inla2 <- post_inla1 %>% mutate(variable = factor(variable, 
                    levels = unique(post_inla1$variable), 
                    labels = c( "2011", "2013", "2015", "2017", 
                                "Range", "Random Field SD", "AR1 rho")))
```


```{r compare-plot, out.width="6in"}
ggplot(post_inla2) + 
  geom_histogram(data=post_sdmTMB2, aes(.value, after_stat(density)), bins = 30, 
                 fill = "blue", alpha = 0.2) + 
  geom_line(data=post_inla2, aes(x, y), inherit.aes = F) + 
  facet_wrap(~variable, scales = "free") 
```
# Distribution map

We can predict on a the grid (`qcs_grid`) provided with the `pcod` data in the sdmTMB package to produce a map of occurrence probabilities in each year. 

```{r sdm-predictions}
nd <- filter(qcs_grid, year >= 2011)
pred <- predict(m, newdata = nd) 

plot_map <- function(dat, column) {
ggplot(dat, aes_string("X", "Y", fill = column)) +
    geom_raster() +
    facet_wrap(~year) +
    coord_fixed()
}
```

```{r maps, cache=FALSE, out.width="6in"}
plot_map(pred, "plogis(est)") +
  scale_fill_viridis_c() +
  ggtitle("Prediction (fixed effects + all random effects)")
```
Similar predictions are more complicated to extract from INLA, but can be plotted for the original sample locations.

```{r inla-pred, out.width="6in"}
idx <- inla.stack.index(sdat, 'stdata')$data

d$inla_pred <- m_inla$summary.fitted.values[idx, "mean"]

ggplot(d) + geom_point(aes(X, Y, colour = inla_pred), size = 2) + facet_wrap(~year) + 
  scale_colour_viridis_c() +
  coord_fixed() +
  ggtitle("Prediction (fixed effects + all random effects)")
```

<!-- predict.inla? -->

<!-- ```{r} -->
<!-- pgrid <- inla.mesh.projector(inla_mesh) -->

<!-- predict(m_inla, pgrid) -->
<!-- ``` -->

<!-- # ```{r epsilon, cache=FALSE, out.width="6in"} -->
<!-- # plot_map(pred, "epsilon_st") + -->
<!-- #   ggtitle("Spatiotemporal random effects only") + -->
<!-- #   scale_fill_gradient2() -->
<!-- # ``` -->
<!-- #  -->
<!-- # ```{r resids, out.width="3in"} -->
<!-- # p <- predict(m) -->
<!-- # p$resid <- residuals(m) -->
<!-- # qqnorm(p$resid) -->
<!-- # qqline(p$resid) -->
<!-- # ``` -->
