---
title: "Appendix 4: species distribution model comparison between inlabru and sdmTMB"
output:
  pdf_document:
    highlight: tango
---

```{r setup, include = FALSE, cache=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.asp = 0.618,
  cache = TRUE,
  autodep = TRUE
)
```


```{r packages, message=FALSE, warning=FALSE, cache=FALSE}
library(ggplot2)
library(dplyr)
library(sdmTMB)
library(INLA)
library(inlabru)
theme_set(ggsidekick::theme_sleek())
```

In this example, we fit a presence-absence species distribution model with fixed effect intercepts for year and spatiotemporal random fields using AR1.  
Once again we will use a data set built into the package: trawl survey data for Pacific Cod in Queen Charlotte Sound.
The density units are kg/km^2^. 
<!-- This can be converted to tonnes per km2 by dividing by 1000, which can sometimes scale better. -->

```{r}
d <- pcod %>% filter(year >= 2011)
yr_lu <- data.frame(year = unique(d$year), i_year = seq_along(unique(d$year)))
d <- dplyr::left_join(d, yr_lu)
```

We will start by building an identical meshes using both sdmTMB and INLA.
Here, X and Y are coordinates in UTM zone 9.
These same functions that are used internally in the sdmTMB `make_mesh()` function. 
```{r sdm-mesh, echo = TRUE, cache=FALSE}
sdm_mesh <- make_mesh(d, xy_cols = c("X", "Y"), cutoff = 10)
```

```{r plot-sdm-mesh, fig.asp=0.9, out.width="3in"}
plot(sdm_mesh)
```

```{r inla-mesh, echo = TRUE, cache=FALSE}
loc_xy <- as.matrix(d[, c("X", "Y"), drop = FALSE])
inla_mesh <- INLA::inla.mesh.create(loc_xy, refine = TRUE, cutoff = 10)

spde <- inla.spde2.pcmatern(
  mesh = inla_mesh, # an smdTMB mesh can be inserted here with sdm_mesh$mesh
    prior.range = c(1, 0.05), # P(range < 1) = 0.05
    prior.sigma = c(10, 0.05))  # P(sigma > 0.1) = 0.05

```

```{r plot-inla-mesh, fig.asp=0.9, out.width="3in"}
plot(spde$mesh)
```
In this example, a PC-prior is used for the temporal autoregressive parameter, i.e., the autocorrelation parameter. 
This prior is defines as P(cor>0) = 0.9:

```{r}
h.spec <- list(rho = list(prior = 'pccor1', param = c(0.7, 0.7)))
```


# INLA 

```{r inla}
tictoc::tic("INLA")

nyear <- length(unique(d$year))

iset <- inla.spde.make.index('i', n.spde = spde$n.spde, n.group = nyear)

A <- inla.spde.make.A(mesh = inla_mesh, loc = loc_xy, group = d$i_year)

sdat <- inla.stack(
  data = list(y = d$present),
  A = list(A, 1),
  effects = list(iset, year_factor = as.factor(d$year)),
  tag = 'stdata')

formulae <- y ~ 0 + year_factor + f(i, model = spde, group = i.group,
  control.group = list(model = 'ar1'))
  # control.group = list(model = 'ar1', hyper = h.spec))

m_inla <- inla(formulae,
  data = inla.stack.data(sdat),
  control.predictor = list(compute = TRUE, A = inla.stack.A(sdat)),
  family = "binomial",
  control.family = list(link = "logit"),
  control.fixed = list(expand.factor.strategy = 'inla', mean = 0, prec = 1/(100*100)),
  verbose = FALSE,
  control.inla = list(int.strategy = "eb", strategy = "gaussian"),
  control.compute = list(config = TRUE)
  )

tictoc::toc()

inla_coefs <- m_inla$summary.fixed[, c("mean", "sd")]
summary(m_inla)
```

# inlabru

*** NOT WORKING YET ***

There are a couple ways to include the fixed effects with `inlabru`. Unfortunately, using factor variables in the standard equation syntax does not work. In the first case, we can create a design matrix and add year effects individually to the formula.


Now we can set up the design matrix for `inlabru`  

```{r echo = TRUE}
m <- lm(present ~ -1 + as.factor(year), data = d)
model_mat <- model.matrix(m)
colnames(model_mat) <- paste0("x", unique(d$year))
dat <- cbind(d, model_mat) %>% mutate(x = X, y = Y)

# dat <- dat %>% sf::st_as_sf(coords = c("x", "y"))

coordinates(dat) <- c("x", "y")
dat <- as(dat, "SpatialPointsDataFrame")
```

Next we set up the `components` object for the model. This includes a formula with fixed or random effects (here only fixed) and the design of the spatial random field. The name `spatrf` can be anything, but includes the coordinates, spde model, and how the year effects are shared. 

```{r eval = F, echo = TRUE}
components <- present ~ 0 + 
    x2009 + x2011 + x2013 + x2015 + x2017  + 
    # x2009(main=x2009, model="linear") +
    # x2011(main=x2011, model="linear") +
    # x2013(main=x2013, model="linear") +
    # x2015(main=x2015, model="linear") +
    # x2017(main=x2017, model="linear") +
    spatrf(coordinates, model = spde, group = year, ngroup=length(unique(d$year)),
      control.group = list(model = 'ar1', hyper = h.spec))

m_bru <- bru(
  components = components,
  family = "binomial",
  options = 
   list(bru_verbose = TRUE, 
        control.fixed = list(expand.factor.strategy = 'inla'),
        control.family = list(link = "logit"),
        control.inla = list(int.strategy = "eb", strategy = "gaussian"),
        control.compute = list(config = TRUE)
  ),
  data = dat
)

bru_coefs <- m_bru$summary.fixed[, c("mean", "sd")]
summary(m_bru)
```


The other way to set up the fixed coefficients with `inlabru` is to use the `fac` argument. Note the location of the parameters changes from to `summary.random$fac`

```{r}
tictoc::tic("bru")

components <- present ~ 0 +
  spatrf(main = coordinates, model = spde, group = dat$year, ngroup=length(unique(dat$year)),
      # control.group = list(model = 'iid')) +
      control.group = list(model = 'ar1')) +
      # control.group = list(model = 'ar1', hyper = h.spec)) +
  # fac(main = year,  model = "iid",
  #     hyper = list(prec = list(initial = log(1e-6),
  #                            fixed = TRUE))
  # )
  fac(main = year,  model = "factor_full")

m_bru <- bru(
  components = components,
  family = "binomial",
  options = 
   list(bru_verbose = TRUE, 
        control.fixed = list(expand.factor.strategy = 'inla'),
        control.family = list(link = "logit"),
        control.inla = list(int.strategy = "eb", strategy = "gaussian"),
        control.compute = list(config = TRUE)
  ),
  data = dat
)
tictoc::toc()

bru_coefs <- m_bru$summary.random$fac[, c("mean", "sd")]
summary(m_bru)
```


```{r}
m_bru <- bru_rerun(m_bru, options = list())
summary(m_bru)
```


Comparing the spatial random effects between `INLA` and `inlabru` shows us that the latter is not estimating well.

```{r}
m_inla$summary.hyperpar[, c("mean", "sd")]
m_bru$summary.hyperpar[, c("mean", "sd")]
```

As a result the fixed effect estimates are also quite different. 

```{r}
plot(inla_coefs$mean, bru_coefs$mean)
abline(a = 0, b = 1)
```


# sdmTMB

We can also fit the model with `sdmTMB`. 
The priors only differ in that... TODO?

```{r sdmtmb}
# mesh <- make_mesh(d, xy_cols = c("X", "Y"), cutoff = 7)
tictoc::tic("sdmTMB")
m <- sdmTMB(present ~ 0 + as.factor(year), 
  data = d, 
  mesh = sdm_mesh, 
  time = "year",
  spatial = "off", 
  spatiotemporal = "AR1", 
  family = binomial(link = "logit"),
  priors = sdmTMBpriors(
    matern_st = pc_matern(range_gt = 1, range_prob = 0.05, # P(range > 1) = 1-0.05
                          sigma_lt = 10, sigma_prob = 0.05), # P(sigma < 10) = 1-0.05
    ar1_rho = normal(0, 1),
    b = normal(0, 100)
  ))
tictoc::toc()


sdmtmb_coefs <- tidy(m, effects = "fixed")

summary(m)
```

```{r}
tidy(m, conf.int = TRUE)
tidy(m, "ran_pars", conf.int = TRUE)
```

Comparing the fixed effects between `sdmTMB` and `inla` shows the estimates are very tightly correlated, but not perfectly so  

```{r}
# plot(sdmtmb_coefs$estimate, bru_coefs$mean)
plot(sdmtmb_coefs$estimate, inla_coefs$mean)
abline(a = 0, b = 1)
```



With sdmTMB, we can extract parameter simulations from the joint precision matrix using `spread_sims()` or `gather_sims()` functions.

```{r sdm-sims}
post_sdmTMB <- gather_sims(m, n_sims = 2000L)

post_sdmTMB2 <- post_sdmTMB %>% mutate(variable = factor(`.variable`, 
                    levels = unique(post_sdmTMB$`.variable`), 
                    labels = c( "2011", "2013", "2015", "2017", "Range", "AR1 rho", "Random Field SD")))
```


We then compare the distribution of these sdmTMB simulations to the marginal posterior densities from INLA. 
From INLA, we can extract the marginal posterior densities using `inla.smarginal()` and name them to match the variable names from the sdmTMB `gather_sims()` function.

```{r inla-densities}
# post_inla <- inla.posterior.sample(result = m_inla, n = 400L)
x <- list()
# x[[1]] <- inla.smarginal(m_inla$marginals.fixed$year_factor2009) %>% as_tibble() %>% 
#   mutate(variable = "as.factor.year.2009")
x[[2]] <- inla.smarginal(m_inla$marginals.fixed$year_factor2011) %>% as_tibble() %>% 
  mutate(variable = "as.factor.year.2011") 
x[[3]] <- inla.smarginal(m_inla$marginals.fixed$year_factor2013) %>% as_tibble() %>% 
  mutate(variable = "as.factor.year.2013") 
x[[4]] <- inla.smarginal(m_inla$marginals.fixed$year_factor2015) %>% as_tibble() %>% 
  mutate(variable = "as.factor.year.2015") 
x[[5]] <- inla.smarginal(m_inla$marginals.fixed$year_factor2017) %>% as_tibble() %>% 
  mutate(variable = "as.factor.year.2017") 
x[[6]] <- inla.smarginal(m_inla$marginals.hyperpar$`Range for i`) %>% as_tibble() %>% 
  mutate(variable = "range") 
x[[7]] <- inla.smarginal(m_inla$marginals.hyperpar$`Stdev for i`) %>% as_tibble() %>% 
  mutate(variable = "sigma_E") 
x[[8]] <- inla.smarginal(m_inla$marginals.hyperpar$`GroupRho for i`) %>% as_tibble() %>% 
  mutate(variable = "ar1_rho") 
post_inla1 <- do.call(rbind, x)

post_inla2 <- post_inla1 %>% mutate(variable = factor(variable, 
                    levels = unique(post_inla1$variable), 
                    labels = c( "2011", "2013", "2015", "2017", "Range", "Random Field SD", "AR1 rho")))
```


```{r compare-plot, out.width="6in"}
ggplot(post_inla2) + 
  geom_histogram(data=post_sdmTMB2, aes(.value, after_stat(density)), binwidth = 0.1, fill = "blue", alpha = 0.2) + 
  geom_line(data=post_inla2, aes(x, y), inherit.aes = F) + 
  facet_wrap(~variable, scales = "free") 
```



<!-- The other way to set up the fixed coefficients with `inlabru` is to use the `fac` argument. Note the location of the parameters changes from to `summary.random$fac` -->

```{r}
# components <- present ~ 0 +
#   fac(main = year, model = "factor_full") +
#   spatrf(main = coordinates, model = spde)
# 
# fit2 <- bru(
#   components = components,
#   family = "binomial", data = dat
# )
# bru_coefs2 <- fit2$summary.random$fac[, c("mean", "sd")]
```

<!-- These estimates are perfectly correlated with the estimates above, -->

```{r}
# plot(bru_coefs$mean, bru_coefs2$mean)
```
