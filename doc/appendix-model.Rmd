---
title: sdmTMB statistical model description
output:
  bookdown::pdf_document2:
    toc: false
number_sections: false
fig_caption: true
highlight: "monochrome"
csl: mee.csl
bibliography: refs.bib
header-includes:
  \usepackage[left]{lineno}
  \usepackage{bm}
  \usepackage{amssymb}
---

```{r setup, echo=FALSE, cache=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = FALSE,
  error = FALSE,
  message = FALSE,
  warning = FALSE
)
```


\newcommand{\s}{\boldsymbol{s}}

# Notation conventions

This appendix uses the following notation conventions:

* Bold lowercase for vectors

* Bold subscript $\s$ (a point in space) since it represents a vector of length 2

* Bold uppercase for matrices

* $\phi$ for all 'dispersion' parameters for consistency with the code

```{r, results='asis'}
symbols <- tibble::tribble(
  ~Symbol, ~Description,
  "$\\phi$", "A dispersion parameter for a distribution",
  "$\\mu$", "Mean",
  "$y$", "Observed response data",
  "$f$", "Link function",
  "$\\omega_{\\s}$", "Spatial random field at point $\\s$",
  "$\\zeta_{\\s, t}$", "Spatially varying coefficient random field at point $\\s$ and time $t$",
  "$\\epsilon_{\\s, t}$", "Spatiotemporal random field",
  "$\\boldsymbol{\\Sigma}_\\omega$", "Spatial random field covariance matrix",
  "$\\boldsymbol{\\Sigma}_\\epsilon$", "Spatiotemporal random field covariance matrix",
  "$\\boldsymbol{\\Sigma}_\\zeta$", "Spatially varying coefficient random field covariance matrix",
  "$\\boldsymbol{\\beta}$", "Parameter vector",
  "$\\boldsymbol{X}$", "Model predictor matrix",
  "$\\alpha_g$", "IID random intercept deviations",
  "$\\sigma_\\alpha^2$", "IID random intercept variance",
  "$\\delta_{\\s,t}$", "AR1 or random walk spatiotemporal deviations",
  "$\\rho$", "Correlation between random fields in subsequent time steps"
)
knitr::kable(symbols, caption = "Symbol notation and descriptions", escape = FALSE, format = "latex", booktabs = TRUE)
```

```{r}
subscripts <- tibble::tribble(
  ~Symbol, ~Description,
  "$\\s$", "Index for space; a vector of x and y coordinates",
  "$t$", "Index for time",
  "$g$", "Group"
)
knitr::kable(subscripts, caption = "Subscript notation", escape = FALSE, format = "latex", booktabs = TRUE)
```

# Combined model structure

As described in the main paper, the complete sdmTMB model can be written as:

$$
\begin{aligned}
\mathbb{E}(y_{\s,t}) &= \mu_{\s,t},\\
\mu_{\bm{s},t} &=
f^{-1} \left( \bm{X}_{1,\bm{s},t} \bm{\beta} +
\bm{\alpha}_g +
\bm{X}_{2,\bm{s},t} \gamma_t +
\bm{X}_{3,t} \zeta_{\bm{s}} +
\omega_{\bm{s}} +
\epsilon_{\bm{s},t} \right),
\end{aligned}
$$

where

* $y$ represents the response data;
* $\mu$ represents the mean;
* $f$ represents a link function (e.g., log or logit) and $f^{-1}$ represents its inverse;
* $\bm{X}_{1}$, $\bm{X}_{2}$, and $\bm{X}_{3}$ represent design matrices;
* $\bm{\beta}$ represents a vector of fixed-effect coefficients;
* $\alpha_{g}$ represents random intercepts by group $g$, $\alpha_{g}\sim \mathrm{N}(0,\sigma^2_\alpha)$;
* $\gamma_{t}$ represents time-varying coefficients (a random walk), $\gamma_{t} \sim \mathrm{N}(\gamma_{t-1},\sigma^2_\gamma)$;
* $\zeta_{\bm{s}}$ represents spatially varying coefficients (a random field), $\zeta_{\bm{s}} \sim \mathrm{MVN}(\bm{0},\bm{\Sigma}_\zeta)$;
* $\omega_{\bm{s}}$ represents a random spatial component (a random field), $\omega_{\bm{s}} \sim \mathrm{MVN}(\bm{0},\bm{\Sigma}_\omega)$; and
* $\epsilon_{\bm{s},t}$ represents a spatiotemporal component (a random field), $\epsilon_{\bm{s},t} \sim \mathrm{MVN}(\bm{0},\bm{\Sigma}_{\epsilon})$.

We now split this model apart to describe the various parts in more detail.

## Main effects

$$
\begin{aligned}
\mu_{\bm{s},t} &= f^{-1} \left( \bm{X}_{1,\bm{s},t} \bm{\beta} \ldots \right)
\end{aligned}
$$

Within `sdmTMB()`, $\bm{X}_{1,\bm{s},t} \bm{\beta}$ is defined by the `formula` argument and represents the main-effect model matrix and a corresponding vector of coefficients. This main effect formula can contain optional penalized smoothers or non-linear functions as defined below.

### Smoothers

Smoothers in sdmTMB are generally implemented with the same formula syntax familiar to mgcv users fitting GAMs (generalized additive models).
Smooths are implemented in the formula using `+ s(x)`, which implements a smooth from `mgcv::s()`. 
Within these smooths, the same syntax commonly used in `mgcv::s()` can be applied, e.g. 2-dimensional smooths may be constructed with `+ s(x, y)`; smooths can be specific to various factor levels, `+ s(x, by = group)`; the basis function dimensions may be specified, e.g. `+ s(x, k = 4)`; and various types of splines may be constructed such as cyclic splines to model seasonality, e.g. `+ s(month, bs = "cc", k = 12)`. 

While mgcv can fit unpenalized (e.g., B-splines) or penalized splines (P-splines), sdmTMB only implements penalized splines. 
The penalized splines are constructed in sdmTMB using the function `mgcv::smooth2random()`, which transforms splines into random effects (and associated design matrices) that are estimable in a mixed-effects modelling framework.
This is a similar approach implemented in `gamm4` and `brms`, among other packages.

### Linear breakpoint threshold models

The linear breakpoint or hockey stick model can be used to describe threshold or asymptotic responses. This function consists of two pieces, so that for $x < b_{1}$, $s(x) = x \cdot b_{0}$, and for $x > b_{1}$, $s(x) = b_{1} \cdot b_{0}$.
In both cases, $b_{0}$ represents the slope of the function up to a threshold, and the product $b_{1} \cdot b_{0}$ represents the value at the asymptote. No constraints are placed on parameters $b_{0}$ or $b_{1}$.

These models can be fit by including `+ breakpt(x)` in the model formula, where
`x` is a covariate.

### Logistic threshold models

Models with logistic threshold relationships between a predictor and the response can be fit with the form

$$
s(x)=\tau + \psi\ { \left[ 1+{ e }^{ -\ln\ \left(19\right) \cdot \left( x-s50 \right)
     / \left(s95 - s50 \right) } \right] }^{-1},
$$

where $s$ represents the logistic function, 
$\psi$ is a scaling parameter (controlling the height of the y-axis for
the response, and is unconstrained), $\tau$ is an intercept, $s50$ is
a parameter controlling the point at which the function reaches 50% of the
maximum ($\psi$), and $s95$ is a parameter controlling the point at which the
function reaches 95%. The parameter $s50$ is unconstrained, and $s95$ is
constrained to be larger than $s50$.

These models can be fit by including `+ logistic(x)` in the model formula, where `x` is a covariate.

## Spatial random fields

Spatial random fields, $\omega_s$, are included if `spatial = 'on'` and omitted if `spatial = 'off'`.

$$
\begin{aligned}
\mu_{\bm{s},t} &= f^{-1} \left( \ldots + \omega_s + \ldots \right),\\
\boldsymbol{\omega} &\sim \operatorname{MVNormal} \left( \boldsymbol{0}, \boldsymbol{\Sigma}_\omega \right),\\ 
\end{aligned}
$$

## Spatiotemporal random fields

Spatiotemporal random fields are included by default if there are multiple time elements (`time` argument is not `NULL`) and can be set to IID (`'iid'`; default), AR1 (`'ar1'`), random walk (`'rw'`), or off (`'off'`) via the `spatiotemporal` argument.

### IID spatiotemporal random fields

IID spatiotemporal random fields (`spatiotemporal = 'iid'`) can be represented as

$$
\begin{aligned}
\mu_{\bm{s},t} &= f^{-1} \left( \ldots + \epsilon_{\s,t} + \ldots \right),\\
\boldsymbol{\epsilon}_t &\sim \operatorname{MVNormal} \left( \boldsymbol{0}, \boldsymbol{\Sigma}_{\epsilon} \right).
\end{aligned}
$$

where $\epsilon_{\s,t}$ represent random field deviations at point $\s$ and time $t$.
The random fields are assumed independent across time slices. 

### AR1 spatiotemporal random fields

AR1 spatiotemporal random fields (`spatiotemporal = 'ar1'`) add a parameter defining the correlation between random field deviations from one time slice to the next. The are defined as

$$
\begin{aligned}
\mu_{\s,t} &= f^{-1} \left( \ldots + \delta_{\s,t} \ldots \right),\\
\boldsymbol{\delta}_{t=1} &\sim \operatorname{MVNormal} (\boldsymbol{0}, \boldsymbol{\Sigma}_{\epsilon}),\\
\boldsymbol{\delta}_{t>1} &= \rho \boldsymbol{\delta}_{t-1} + \sqrt{1 - \rho^2} \boldsymbol{\epsilon}_t,  \:
\boldsymbol{\epsilon}_t \sim \operatorname{MVNormal} \left(\boldsymbol{0}, \boldsymbol{\Sigma}_{\epsilon} \right),
\end{aligned}
$$
where $\rho$ is the correlation between subsequent spatiotemporal random fields. The $\rho \boldsymbol{\delta}_{t-1} + \sqrt{1 - \rho^2}$ scales the spatiotemporal variance by the correlation such that it represents the steady-state marginal variance.
The correlation $\rho$ allows for mean-reverting spatiotemporal fields, and is constrained to be $-1 < \rho < 1$.

### Random walk spatiotemporal random fields (RW)

Random walk spatiotemporal random fields (`spatiotemporal = 'rw'`) represent a model where the difference in spatiotemporal deviations from one time slice to the next are IID. There defined as

$$
\begin{aligned}
\mu_{\s,t} &= f^{-1} \left( \ldots + \delta_{\s,t} + \ldots \right),\\
\boldsymbol{\delta}_{t=1} &\sim \operatorname{MVNormal} (\boldsymbol{0}, \boldsymbol{\Sigma}_{\epsilon}),\\
\boldsymbol{\delta}_{t>1} &= \boldsymbol{\delta}_{t-1} +  \boldsymbol{\epsilon}_{t-1},  \:
\boldsymbol{\epsilon}_{t-1} \sim \operatorname{MVNormal} \left(\boldsymbol{0}, \boldsymbol{\Sigma}_{\epsilon} \right),
\end{aligned}
$$

where the distribution of the spatiotemporal field in the initial time step is the same as for the AR(1) model, but the absence of the $\rho$ parameter allows the spatiotemporal field to be non-stationary in time.
Note that, in contrast to the AR1 parametrization, the variance is no longer the steady-state marginal variance.

<!-- * $\alpha_g$, are defined by an lme4-style formula, e.g. `formula = y ~ x + (1 | g)`, where `g` represents a column with grouping factors. -->

<!-- * $\gamma_{t}$, time-varying coefficients, are defined by the `time_varying` formula argument. -->

<!-- * $\zeta_{\bm{s}}$, IID random intercepts, are defined by the `spatial_varying` formula argument. -->

<!-- * $f$ and $f^-1$ functions are defined by the `family` argument. E.g., `family = Gamma(link = "log")`. -->

## Spatially varying coefficients (SVC)

Spatially varying coefficient (SVC) models are defined as

$$
\begin{aligned}
  \mu_{\s,t} &= f^{-1} \left( \ldots + \bm{X}_{3,t} \zeta_{\bm{s}} + \ldots \right),\\
  \boldsymbol{\zeta} &\sim \operatorname{MVNormal} \left( \boldsymbol{0}, \boldsymbol{\Sigma}_\zeta \right),
\end{aligned}
$$

where $\boldsymbol{\zeta}$ is a random field representing a spatially varying coefficient.
Usually, $\bm{X}_{3,t}$ would represent a predictor that is constant for a given time $t$.
Currently, $\bm{X}_{3,t}$ is restricted to a single covariate, supplied by a formula to `spatial_varying`.

## IID random or multi-level intercepts

$$
\begin{aligned}
  \mu_{\s,t} &= f^{-1} \left( \ldots + \alpha_{g} + \ldots \right),\\
  \alpha_g &\sim \operatorname{Normal} \left(0, \sigma_\alpha^2 \right),\\
\end{aligned}
$$

where $\alpha_g$ is an example optional "random" intercept---an intercept
centered on zero that varies by level $g$ and is constrained by
$\sigma_\alpha$. This is defined by the `formula` argument via the `(1 | g)`
syntax as in lme4 or glmmTMB. There can be multiple random intercepts. 
E.g., `(1 | g) + (1 | h)`, in which case they are assumed independent and uncorrelated from each other.

## Time-varying regression parameters

Parameters can be modelled as time varying (a random walk) according to the form

$$
\begin{aligned}
  \mu_{\s,t} &= f^{-1} \left( \ldots + \gamma_{t} x_{\s,t} + \ldots \right),\\
  \gamma_{t=1} &\sim \operatorname{Uniform} \left(-\infty, \infty \right),\\
  \gamma_{t>1} &\sim \operatorname{Normal} \left(\gamma_{t-1}, \sigma^2_{\gamma} \right),
\end{aligned}
$$

where $\gamma_t$ is an example optional time-varying regression parameter and $x_{\s,t}$ is the corresponding predictor value.
This is defined via the `time_varying` argument, assuming that the `time` argument is also supplied a column name.
For example, `time_varying ~ 0 + x`.
The first value is given an implicit uniform prior. 
I.e., the same variable should not appear in the fixed effect formula since the initial value is estimated as part of the time-varying formula.
The formula `time_varying = ~ 1` implicitly represents a time-varying intercept and the intercept should be omitted from the main effects (`~ + 0` or `~ -1`).

## Offset terms

Offset terms can be included with the reserved word `offset` in the formula.
E.g., `y ~ x + offset`.
These are included in the linear predictor as

$$
\begin{aligned}
  \mu_{\s,t} &= f^{-1} \left( \ldots + O_{\s,t} + \ldots \right),
\end{aligned}
$$

where $O_{\s,t}$ is an offset term---a **log transformed** variable without a coefficient (assuming a log link).

# Observation model families

## [Binomial](https://kaskr.github.io/adcomp/group__R__style__distribution.html#gaee11f805f02bc1febc6d7bf0487671be)

Internally parameterized as the [robust
version](https://kaskr.github.io/adcomp/group__R__style__distribution.html#gaecb5a18095a320b42e2d20c4b120f5f5).

## [Beta](https://kaskr.github.io/adcomp/group__R__style__distribution.html#ga5324c83759d5211c7c2fbbad37fa8e59)

$$
\operatorname{Beta} \left(\mu \phi, 1 - \mu \phi \right)
$$

where $\phi$ is variance.

$$
\operatorname{Binomial} \left( N, \mu \right)
$$

where $N$ is the size or number of trials and $\mu$ is the probability.

Following the structure of `stats::glm()` and glmmTMB, a binomial family can be specified in one of 4 ways:

1. the response may be a factor (and the model classifies the first level versus all others)
2. the response may be binomial (0/1)
3. the response can be a matrix of form `cbind(success, failure)`, and 
4. the response may be the observed proportions, and the `weights` argument is used to specify the Binomial size ($N$) parameter (`prob ~ ..., weights = N`).

## [Gamma](https://kaskr.github.io/adcomp/group__R__style__distribution.html#gab0e2205710a698ad6a0ed39e0652c9a3)

As shape, scale:

$$
\operatorname{Gamma} \left( \phi, \frac{\mu}{\phi}  \right)
$$

where $\phi$ represents the shape and $\frac{\mu}{\phi}$ represents the scale.

## [Gaussian](https://kaskr.github.io/adcomp/dnorm_8hpp.html)

$$
\operatorname{Normal} \left( \mu, \phi \right)
$$
where $\mu$ is the mean and $\phi$ is the standard deviation (following Stan convention of SD not variance).

## [Lognormal](https://github.com/pbs-assess/sdmTMB/blob/28a93496a93b12e5a2f73f703bc96afbf14d86c1/src/sdmTMB.cpp#L22-L30)

$$
\operatorname{Lognormal} \left( \log \mu - \frac{\phi^2}{2}, \phi \right)
$$

where $\mu$ and $\phi$ are the mean and standard deviation of the natural log of the random variable. If $X$ is lognormally distributed, $E[log(X)] = \mu$ and $Var(log(X)) = \phi$. The expectation of $X$ is $exp(u + \frac{\phi^2}{2})$ and variance of X is $\left(exp(\phi^2) - 1 \right)exp(2\mu + \phi^2)$. 

## [Negative Binomial 2 (NB2)](https://kaskr.github.io/adcomp/group__R__style__distribution.html#ga76266c19046e04b651fce93aa0810351)

$$
\operatorname{NB2} \left( \mu, \phi \right)
$$

Where $\mu$ is the mean and $\phi$ is the dispersion parameter.
The variance scales quadratically with the mean $\mathrm{Var}[y] = \mu + \mu^2 / \phi$.

Internally parameterized as the [robust version](https://kaskr.github.io/adcomp/group__R__style__distribution.html#gaa23e3ede4669d941b0b54314ed42a75c) in TMB.

## [Negative Binomial 1 (NB1)](https://kaskr.github.io/adcomp/group__R__style__distribution.html#ga76266c19046e04b651fce93aa0810351)

$$
\operatorname{NB1} \left( \mu, \phi \right)
$$
Where $\mu$ is the mean and $\phi$ is the dispersion parameter.
The variance scales linearly with the mean $\mathrm{Var}[y] = \mu + \mu / \phi$.

Internally parameterized as the [robust version](https://kaskr.github.io/adcomp/group__R__style__distribution.html#gaa23e3ede4669d941b0b54314ed42a75c) in TMB.

## [Poisson](https://kaskr.github.io/adcomp/group__R__style__distribution.html#gaa1ed15503e1441a381102a8c4c9baaf1)

$$
\operatorname{Poisson} \left( \mu \right)
$$

## [Censored-poisson] TODO

## [Student-t](https://github.com/pbs-assess/sdmTMB/blob/28a93496a93b12e5a2f73f703bc96afbf14d86c1/src/sdmTMB.cpp#L11-L20)

$$
\operatorname{Student-t} \left( \mu, \phi, \nu \right)
$$

where $\nu$, the degrees of freedom, is currently fixed at 3.

## [Tweedie](https://kaskr.github.io/adcomp/group__R__style__distribution.html#ga262f3c2d1cf36f322a62d902a608aae0)

[Source code](https://kaskr.github.io/adcomp/tweedie_8cpp_source.html) as in [cplm](https://CRAN.R-project.org/package=cplm) package. <https://link.springer.com/article/10.1007/s11222-012-9343-7>

$$
\operatorname{Tweedie} \left(\mu, p, \phi \right), \: 1 < p < 2
$$

where $\mu$ is the mean, $p$ is the power parameter constrained between 1 and 1, and $\phi$ is the dispersion parameter.

# Random field details

## Matern parameterization

The Matérn defines the covariance $\Phi \left( s_j, s_k \right)$ between spatial locations $s_j$ and $s_k$ as 

$$
\Phi\left( s_j,s_k \right) = \tau^2/\Gamma(\nu)2^{\nu - 1} (\kappa d_{jk})^\nu K_\nu \left( \kappa d_{jk} \right),$$
<!-- TODO: paraphrase this to avoid self plagiarizing the synopsis report! -->

where $\tau^2$ controls the spatial variance, $\Gamma$ represents the Gamma function, $K_\nu$ represents the Bessel function, $d_{jk}$ represents the Euclidean distance between locations $s_j$ and $s_k$, and $\kappa$ represents a scaling parameter that controls the decorrelation distance (REF).
The parameter $\nu$ controls the smoothness of the covariance function.
We set $\nu = 1$, which lets us take advantage of the Stochastic Partial Differential Equation (SPDE) approximation to the GMRF to greatly increase computational efficiency [@lindgren2011].
  
## Projection 'A' matrix

TODO

## Anisoptropy

TMB allows for anisotropy, where spatial covariance may be asymmetric with respect to latitude and longtidue ([full details](https://kaskr.github.io/adcomp/namespaceR__inla.html)). Anistropy can be turned on and off with the boolean `anisotropy` argument to `sdmTMB()`. There are a number of ways to implement anisotropic covariance (Fuglstad et al. 2015), and we adopt a 2-parameter rotation matrix $\textbf{H}$. The elements of $\textbf{H}$ are defined by the parameter vector $\textbf{x}$ so that $H_{1,1} = x_{1}$, $H_{1,2} = H_{2,1} = x_{2}$ and $H_{2,2} = (1 + x_{2}^2) / x_{1}$

Once a model is fitted with `sdmTMB()`, the anisotropy relationships may be plotted using the `plot_anisotropy()` function, which takes the fitted object as an argument. Note: if you use a barrier mesh, anisotropy is disabled. 

## Barrier mesh

TODO

# Optimization details

The sdmTMB model is fit by maximum marginal likelihood.
Internally, a TMB [@kristensen2016] model template calculates the marginal log likelihood and its gradient, and the negative log likelihood is minimized via the non-linear optimization routine `stats::nlminb()` in R [@gay1990; @r2021].
Random effects are estimated at values that maximize the log likelihood conditional on the estimated fixed effects and are integrated over via the Laplace approximation [@kristensen2016].

Like AD Model Builder, TMB allows for parameters to be fit in phases and we inlcude the `multiphase` argument in `sdmTMB::sdmTMBcontrol()` to allow this. For high dimensional models (lots of fixed and random effects), phased estimation may be faster and result in more stable convergence. In sdmTMB, phased estimation proceeds by first estimating all fixed effect parameters contributing to the likelihood (holding random effects constant at initial values). In the second phase, the random effect parameters (and their variances) are also estimated. Fixed effect parameters are also estimated in the second phase, and initialized at their estimates from the first phase.  

In some cases, a single call to `stats::nlminb()` may not be result in convergence (or a small maximum gradient), and the algorithm may need to be run multiple times. In the `sdmTMB::sdmTMBcontrol()` function, we include an argument `nlminb_loops` that will restart the optimization at the previous best values. The number of `nlminb_loops` should generally be small (e.g. 2 or 3 initially), and defaults to 1. For some sdmTMB models, the Hessian may also be unstable and need to be re-evaluated. We do this optionally with the `stats::optimHess()` routine after the call to `stats::nlminb()`. The `stats::optimHess()` function implements a Newton optimization routine to find the Hessian, and we include the argument `newton_loops` in `sdmTMB::sdmTMBcontrol()` to allow for multiple function evaluations (each starting at the previous best value). By default, this is not included and `newton_loops` is set to 0.

# Assessing convergence

TODO

# References
