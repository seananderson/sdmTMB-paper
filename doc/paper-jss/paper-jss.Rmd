---
documentclass: jss
author:
  - name: Sean C. Anderson
    orcid: 0000-0001-9563-1937
    affiliation: 'Pacific Biological Station'
    address: |
      | Fisheries and Oceans Canada, Nanaimo, BC, Canada
    email: \email{sean.anderson@dfo-mpo.gc.ca}
  - name: Eric J. Ward
    orcid: 0000-0002-4359-0296
    affiliation: 'Northwest Fisheries Science Center \AND'
    address: |
      | National Oceanic and Atmospheric Administration, National Marine Fisheries Service, Seattle, WA, USA
  - name: Philina A. English
    orcid: 0000-0003-2992-6782
    affiliation: 'Pacific Biological Station'
    address: |
      | Fisheries and Oceans Canada, Nanaimo, BC, Canada
  - name: Lewis A. K. Barnett
    orcid: 0000-0002-9381-8375
    affiliation: 'Alaska Fisheries Science Center'
    address: |
      | National Marine Fisheries Service, National Oceanic and Atmospheric Administration, Seattle, WA, USA
bibliography: refs.bib
title:
  formatted: "\\pkg{sdmTMB}: An \\proglang{R} Package for Fast, Flexible, and User-Friendly Generalized Linear Mixed Effects Models with Spatial and Spatiotemporal Random Fields"
  # If you use tex in the formatted title, also supply version without
  plain:     "sdmTMB: An R Package for Fast, Flexible, and Accessible Generalized Linear Mixed Effects Models with Spatial and Spatiotemporal Random Fields"
  # For running headers, if needed
  short:     "\\pkg{sdmTMB}: geostatistical SPDE-based GLMMs with \\pkg{TMB}"
abstract: >
  Geostatistical data are common across scientific fields and available in increasingly large datasets. However, appropriate models to analyse these data, such as generalised linear mixed effects models with Gaussian random fields, are computationally intensive and challenging to implement for many users. Here, we introduce the \proglang{R} package \pkg{sdmTMB}, which extends the flexible interface familiar to users of \pkg{lme4}, \pkg{glmmTMB}, or \pkg{mgcv} to include spatial and spatiotemporal latent fields using a predictive-process SPDE-(stochastic partial differential equation) based approach. SPDE matrices are constructed with \proglang{R}-\pkg{INLA} and estimation is conducted via maximum marginal likelihood with Template Model Builder (\pkg{TMB}) or via Bayesian inference with \pkg{tmbstan} and \pkg{rstan}. We describe the model and explore case studies that illustrate \pkg{sdmTMB}'s flexibility in implementing penalised smoothers, non-stationary processes (time-varying and spatially varying coefficients), and anisotropy (directionally dependent spatial correlation). Additional functionality includes hurdle models, break-point effects, and out-of-sample cross validation. Finally, we compare the functionality, speed, and interfaces of related software, demonstrating that \pkg{sdmTMB} can be an order of magnitude faster than \proglang{R}-\pkg{INLA}. We hope \pkg{sdmTMB}'s accessible interface will help open this useful class of models to a wider field of geostatistical analysts.
keywords:
  # at least one keyword must be supplied
  formatted: [Gaussian Markov random fields (GMRF), generalized linear mixed effects models (GLMM), INLA, SPDE, species distribution modelling, R package, spatio-temporal, spatial-temporal, Template Model Builder]
  plain:     [Gaussian Markov random fields (GMRF), generalized linear mixed effects models (GLMM), INLA, SPDE, species distribution modelling, R package, spatio-temporal, spatial-temporal, Template Model Builder]
preamble: >
  \usepackage{amsmath}
  \usepackage{amssymb}
  \usepackage{bm}
  \usepackage{lscape}
  \usepackage{tablefootnote}
  \usepackage{threeparttable}
  \usepackage{booktabs}
  \usepackage{pifont}
  \usepackage{newunicodechar}
  \usepackage{gensymb}
  \newunicodechar{✓}{\ding{51}}
  \newunicodechar{✗}{\ding{55}}
  \newunicodechar{˚}{\degree}
  \DeclareGraphicsExtensions{.pdf,.png,.jpg}
  \widowpenalty10000
  \clubpenalty10000
output: rticles::jss_article
---

<<main-setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  collapse = TRUE,
  comment = "#>",
  # prompt = FALSE,
  cache = TRUE,
  autodep = TRUE,
  fig.width = 7,
  fig.asp = 0.618,
  fig.pos = "ht",
  cache.comments = TRUE,
  dev = "pdf",
  dpi = 140,
  optipng = "-strip all"
  # R.options = list(prompt = "R> ", continue = "+ ")
)
knitr::knit_hooks$set(optipng = knitr::hook_optipng)
options(prompt = "R> ", continue = "+  ", width = 72, useFancyQuotes = FALSE)
```

\clearpage
# Introduction

Data are often collected in space or in space repeatedly over time.
While such data are a rich source of information [e.g., @legendre1989a; @rossi1992; @tilman1997spatial], they are challenging to properly model---data closer in space and time are usually more similar to each other than data farther apart due to measured and unmeasured variables [@cressie1993; @diggle2007; @cressie2011].
While measured variables can be accounted for with predictors in a model (e.g., measuring and modelling temperature effects on species abundance), unmeasured variables (e.g., everything influencing species abundance but not explicitly modelled) can cause residual spatial correlation.
Accounting for this residual correlation is important because doing so allows for valid statistical inference [@legendre1989a; @dormann2007], can improve predictions  [e.g., @shelton2014], and can be of interest itself [e.g., @thorson2019d; @barnett2021].

Geostatistical generalized linear mixed effects models (GLMMs) with spatially correlated random effects are a class of models appropriate for these data [@rue2005gmrf; @diggle2007; @cressie2011].
Similarly to how random intercepts can account for correlation among groups, spatial or spatiotemporal random effects can account for unmeasured variables causing observations to be correlated in space or space and time.
A common approach to modelling these spatial effects is with Gaussian random fields (GRFs), where the random effects describing the spatial patterning are assumed to be drawn from a multivariate normal (MVN) distribution, constrained by some covariance function such as the exponential or Matérn [@cressie1993; @diggle2007; @chiles1999].

Such models quickly become computationally limiting due to the need to invert large matrices to keep track of covariation among data [e.g., @rue2005gmrf; @latimer2009].
Many solutions have been proposed, such as predictive processes [@banerjee2008; @latimer2009], the stochastic partial differential equation (SPDE) approximation to GRFs [@lindgren2011], and nearest-neighbour Gaussian processes [@datta2016; @finley2022].
These approaches reduce the scale of the covariance estimation problem while providing a means to evaluate the data likelihood, thereby allowing fitting via Bayesian [@gelfand2017] or maximum likelihood methods.
This can greatly improve computational efficiency [e.g., @heaton2019].
The SPDE approach is a solution popularized via the \proglang{R}-\pkg{INLA} package [@rue2009; @lindgren2011; @lindgren2015] and an implementation in \pkg{TMB} [Template Model Builder, @kristensen2016] that relies on \proglang{R}-\pkg{INLA} to create input matrices [e.g., @thorson2019; @osgood-zimmerman2021].
Details are beyond the scope of this paper and are not necessary to use the software discussed here, but the idea is that the solution to a specific SPDE is a GRF with a Matérn covariance function and this 'trick' enables one to efficiently fit approximations to GRFs to large spatial datasets [@lindgren2011].

Software packages for specifying statistical models that can include the SPDE, such as \proglang{R}-\pkg{INLA} and \pkg{TMB}, are flexible and powerful but are challenging to use for many applied researchers.
For example, \pkg{TMB} requires the user to program in a \proglang{C++} template and it can be slow to experiment with multiple models when writing bespoke model code.
Packages such as \pkg{lme4} [@bates2015] and \pkg{glmmTMB} [@brooks2017] let users quickly iterate and explore statistical models---focusing on evaluating fit and comparing models---but do not have built-in SPDE functionality.
Packages such as \pkg{VAST} [@thorson2019] and \pkg{inlabru} [@bachl2019] are powerful user interfaces to fit spatial models that use the SPDE, but they either lack a modular interface familiar to those who have used \pkg{lme4} or \pkg{glmmTMB}, or lack some functionality.
We provide a more detailed comparison of related software packages in Table \ref{tab:functionality} and the Discussion.

Here, we introduce the \proglang{R} package \pkg{sdmTMB}, which implements geostatistical spatial and spatiotemporal GLMMs using \pkg{TMB} for model fitting and \proglang{R}-\pkg{INLA} to set up SPDE matrices.
Our aim is not to replace the above-mentioned statistical packages, but to provide a fast, flexible, and user-friendly interface that is familiar to users of \pkg{lme4}, \pkg{glmmTMB}, or \pkg{mgcv} [@wood2017a] for a specific class of spatial and spatiotemporal models. Many features of \pkg{sdmTMB} may be found in other software (Table 1) but to date no package has included all in a single package. 
One common application in the field of ecology is species distribution models (SDMs), hence the package name (i.e., SDMs with \pkg{TMB}: \pkg{sdmTMB}).
This paper describes the basic functionality of this \proglang{R} package and its underlying statistical model, illustrates its use through two case studies, and concludes with a comparison to related software.

# Model description

\pkg{sdmTMB} fits GLMMs to spatial or spatiotemporal geostatistical data.
Geostatistical data refers to data observed at specific spatial coordinates reflecting some underlying spatial process [@rossi1992; @diggle2007].
These data can be collected across discrete points in time.
Areal data (data aggregated to polygon or grid level) may be analyzed using other spatial models, including conditional (CAR) autoregressive models [e.g., @verhoef2018];
\pkg{sdmTMB} can also fit models with areal data if each polygon has an associated centroid.
A benefit of the geostatistical approach over CAR or similar models is that the parameters describing spatial covariance can be more easily interpreted [@wall2004] (e.g., spatial variance and range---the distance at which points are effectively independent).

The process component of an \pkg{sdmTMB} model can be formed by any combination of main ("fixed") effects $\bm{\beta}$ and offset $O_{\bm{s},t}$, IID (independent and identically distributed) random intercepts $\alpha_g$, spatial intercept random fields $\omega_{\bm{s}}$, spatiotemporal intercept random fields $\epsilon_{\bm{s},t}$, time-varying effects $\bm{\gamma_t}$, and spatially varying effects $\zeta_{\bm{s}}$ (Figure \ref{fig:diagram}). These components are discussed in more detail via our examples below.

$$
\begin{aligned}
\mu_{\bm{s},t} &=
g^{-1} \left( \bm{X}^{\mathrm{main}}_{\bm{s},t} \bm{\beta} +
O_{\bm{s},t} +
\alpha_g +
\omega_{\bm{s}} +
\epsilon_{\bm{s},t} + 
\bm{X}^{\mathrm{tvc}}_{\bm{s},t} \bm{\gamma_t} +
\bm{X}^{\mathrm{svc}}_{\bm{s},t} \zeta_{\bm{s}} \right),
\end{aligned}
$$
This process component is combined with an observation error family (e.g., Gaussian, gamma, binomial, Tweedie) and link function $g$ (e.g., identity, log, logit) as in any generalized linear model (GLM) [@mccullagh1989].
Some families can be combined into a two-part "delta" or "hurdle" model [@aitchison1955] to model the zero vs. non-zero observations separately from the positive observations.
See the model description vignette for an expanded description of the statistical model (`browseVignettes("sdmTMB")` or see the \href{https://pbs-assess.github.io/sdmTMB/articles/}{rendered version}).

The GLMMs underpinning \pkg{sdmTMB} models are spatially explicit---they estimate interpretable parameters of a spatial covariance function: parameters defining the magnitude of spatial variation and the rate of correlation decay with distance.
In contrast, semi- and non-parametric approaches do not estimate spatial covariance functions (e.g., \pkg{randomForest} [@liaw2002], \pkg{MaxEnt} [@phillips2006], and most smooths in \pkg{mgcv} [@wood2017a]).
The random fields in \pkg{sdmTMB} are structured as MVN constrained by a Matérn covariance function [@matern1960].
The Matérn can accommodate a range of shapes and can be both isotropic (correlation decays the same in all directions) or anisotropic (correlation is directionally dependent) [@haskard2007].
The Matérn standard deviations are estimated separately for the various fields and the range---the distance at which spatial correlation decays to $\sim 0.13$ [@lindgren2015]---can be shared among random fields or estimated separately (`share_range` argument).

By default, if spatiotemporal fields are included, they are assumed IID; however, additional options allow them to be modelled as a random walk or first-order autoregressive, AR(1), process (Figure \ref{fig:diagram}).
Turning off both spatial and spatiotemporal effects allows for comparison with standard non-spatial GLMs or GLMMs.
We include additional flexibility in specifying the linear main effect matrix: covariates can be modelled as penalized smooth functions (generalized additive models, GAMs) using the same `s()` syntax as in \pkg{mgcv} [@wood2017a] (thereby allowing automatic selection of smoother 'wiggliness'), or can be modelled with threshold shapes: hockey-stick models, `breakpt()`, [@barrowman2000] or logistic functions, `logistic()`.
\pkg{sdmTMB} can use many `mgcv::s()` and `mgcv::t2()` smoothers including bivarate smoothers `s(x, y)`, smoothers varying by continuous or categorical variables `s(x1, by = x2)`, cyclical smoothers `s(x, bs = "cc")`, and smoothers with specified basis dimensions `s(x, k = 4)` [@wood2017a].

The \pkg{sdmTMB} model is fit by maximum marginal likelihood.
Internally, a \pkg{TMB} [@kristensen2016] model template is used to calculate the marginal log likelihood and its gradient, and the negative log likelihood is minimized via the non-linear optimization routine `stats::nlminb()` in \proglang{R} [@gay1990; @r2021].
Random effects are estimated at values that maximize the log likelihood conditional on the estimated fixed effects and are integrated over via the Laplace approximation [@kristensen2016].
After rapid model exploration with maximum likelihood, one can optionally pass an \pkg{sdmTMB} model to the \proglang{R} package \pkg{rstan} [@carpenter2017; @rstan] via \pkg{tmbstan} [@monnahan2018] to estimate the joint posterior distribution for Bayesian inference.

\pkg{sdmTMB} models can include penalized likelihoods by assigning priors to model parameters (`?sdmTMBpriors`).
These priors may be useful in cases where estimation is difficult because of identifiability issues or relatively flat likelihood surfaces, or to impart prior information or achieve regularization.
Following other recent SPDE implementations in \pkg{TMB} [@breivik2021; @osgood-zimmerman2021], penalized complexity (PC) priors [@simpson2017; @fuglstad2019] (`?pc_matern`) can constrain the spatial range and variance parameters. 

The \pkg{sdmTMB} package is constructed from S3 classes and designed to be both modular and familiar to users of widely used \proglang{R} packages (e.g. \pkg{glmmTMB}, \pkg{lme4}, \pkg{mgcv}). Data may be simulated with or without a fitted model (`simulate.sdmTMB()`, `sdmTMB_simulate()` respectively). Estimation is done via maximum marginal likelihood with the `sdmTMB()` function, and the resulting fitted model can be used to make predictions (`predict.sdmTMB()`) or calculate residuals (`residuals.sdmTMB()`), derive additional quantities of interest, and simulate Bayesian posterior distributions. Common quantities of interest may include summarizing shifts in the center of gravity (`get_cog()`) [e.g., @thorson2016cog], or tracking total densities through time (`get_index()`). The `get_index()` function generates a weighted average of densities for the prediction grid, integrating across space; for prediction grids with equally sized cells, each cell will contribute equally to the total average, however cells may be of unequal size.
<!-- TODO: describe this in more detail and how it could apply beyond ecology; maybe a derived variables subsection? Expanded this sentence a bit -- COGs are pretty common in other fields, but I don't know about indices -- removed `ecology` from the description-->

\begin{landscape}
\begin{figure}[p]
\centering
\includegraphics[width=9in]{../../figs/diagram}
\caption[]{
Components of an \pkg{sdmTMB} model with illustrations, descriptions, examples, notation, and example code.
An \pkg{sdmTMB} model can be built from any combination of the process components (first six rows) plus an observation component (last row).
The examples are from an SDM context, but the model can be fit to any spatially referenced point data.
Notation:
We refer to design matrices as $\bm{X}$.
The indexes $\bm{s}$, $t$, and $g$ index spatial coordinates, time, and group, respectively.
The $\sigma$ and $\bm{\Sigma}$ symbols represent standard deviations and covariance matrices, respectively.
All other symbols refer to the  described model components (e.g., $\bm{\beta}$ and $\bm{\omega}$ refer to a vector of main effects and spatial random field deviations, respectively).
See the \pkg{sdmTMB} \href{https://pbs-assess.github.io/sdmTMB/articles/}{model description vignette} for a full description of the model.
Note that \code{s()} denotes a smoother as in \pkg{mgcv} \citep{wood2017a}, \code{breakpt()} denotes a breakpoint 'hockey-stick' shape \citep[e.g.][]{barrowman2000}, \code{(1|g)} denotes a random intercept by group \code{g}, and \code{\textasciitilde\ 0} is used in an \proglang{R} formula to omit an intercept.}\label{fig:diagram}
\end{figure}
\end{landscape}

# Model validation and selection

Validation and selection of state-space models is challenging, particularly when using the Laplace approximation [@thygesen2017a].
We provide several approaches to assist this process:
(1) The Akaike Information Criterion [AIC, @akaike1974] can be calculated with `AIC()`, although AIC has well-documented biases with mixed-effects models [@liang2008].
(2) Alternatively, k-fold cross validation with `sdmTMB_cv()` can be used with user-specified or randomly chosen folds for model selection or to evaluate goodness of fit according to user-calculated criteria (e.g., mean squared error, area under the curve).
(3) An \pkg{sdmTMB} model can be passed to the \pkg{tmbstan} package [@monnahan2018] to sample from the joint posterior with Stan [@carpenter2017], evaluate the accuracy of the Laplace approximation, or perform posterior predictive checks (see `?extract_mcmc`).
(4) The `residuals()` method by default returns randomized quantile [@dunn1996] or probability integral transform (PIT) [@smith1985] residuals.
<!-- These residuals, however, are calculated as $\hat{y} - y$ where $\hat{y}$ is the sum of the fixed effect estimates and the random effect values that maximize the likelihood conditional on the estimated fixed effects.  -->
For state-space models, these residuals have known statistical issues with the Laplace approximation [@thygesen2017a] but are quick to calculate.
A version that uses Markov chain Monte Carlo (MCMC) sampling of the random effects to avoid this issue [@rufener2021] is recommended but slower (`?residuals.sdmTMB`).
Simulation-based residuals [@dharma] are also possible.
(5) The `simulate.sdmTMB()` method can simulate from fitted models and the `sdmTMB_simulate()` function facilitates simulating data without starting from a fitted model.
Models can be fit to these simulated data to ensure identifiability, evaluate bias and precision in parameter estimation, or evaluate the consequences of model misspecification.

\clearpage

# Package comparisons

TODO: BEFORE OR AFTER EXAMPLES

There are many \proglang{R} packages capable of fitting geostatistical spatial or spatiotemporal models [e.g., @heaton2019].
\pkg{sdmTMB}, \pkg{VAST}, \proglang{R}-\pkg{INLA}/\pkg{inlabru}, and \pkg{spaMM} [@rousset2014] are the most closely related, as they all provide a user interface to SPDE-based GRF models.
In our software comparison (Table \ref{tab:functionality}), we also include \pkg{mgcv} as it can be adapted to use the SPDE [@miller2019] and \pkg{spBayes} [@finley2007; @finley2015] since it is a prominent package that can fit related predictive-process models without the SPDE.
\pkg{sdmTMB}, \pkg{VAST}, and \pkg{mgcv} can estimate anisotropic covariance whereas \proglang{R}-\pkg{INLA}/\pkg{inlabru} and \pkg{spBayes} are currently limited to isotropic covariance.
\pkg{sdmTMB} and \pkg{mgcv} focus on univariate response data, whereas \pkg{VAST}, \proglang{R}-\pkg{INLA}/\pkg{inlabru}, \pkg{spaMM}, and \pkg{spBayes} extend to multivariate responses with various limitations.
To our knowledge, \pkg{VAST} is the only package to implement spatial [@thorson2015] and spatial dynamic factor analysis [@thorson2016] and spatial empirical orthogonal function (EOF) regression [@thorson2020].
Of these packages, only \pkg{sdmTMB} and \pkg{inlabru} can currently fit threshold (e.g., hockey-stick) covariate relationships.
\pkg{spaMM} is limited to a spatial random field (i.e., does not fit spatiotemporal fields) and \pkg{spBayes} implements spatiotemporal fields, but only as a random walk.
There is considerable variability in the available observation likelihoods across packages (Table \ref{tab:functionality}).
We provide comparisons of the syntax and the reproducibility of results from models fit using \pkg{sdmTMB}, \proglang{R}-\pkg{INLA}, and \pkg{inlabru} in Appendix&nbsp;\ref{app:inla}.
<!-- and \pkg{VAST} (Appendix 5). -->

<<compare-table, results='asis', eval=FALSE>>=
library(kableExtra)
suppressMessages(suppressWarnings(d <- readr::read_csv(here::here("doc/software-comparison.csv"), show_col_types = FALSE, comment = "#")))
d <- as.matrix(d)
# d[d == "1"] <- "\\checkmark"
d <- gsub("^1", "\\\\checkmark", d)
# d[d == "1*"] <- "\\checkmark\\footnote{a}"
# d[d == "GAMs*"] <- "GAMs\\footnote{a}"
# d[d == "0"] <- "--"
d <- gsub("^0", "--", d)
# d[d == "0*"] <- "--\\footnote{a}"
d <- as.data.frame(d)
names(d)[1] <- ""
row.names(d) <- NULL
d <- d[,c(1, 2, 3, 5, 6, 4, 7, 8, 9)]
d$Hmsc <- NULL

d$INLA <- NULL
names(d)[names(d) == "inlabru"] <- "INLA/inlabru"

knitr::kable(d, format = "latex", caption = "Comparison of functionality between several R packages that can fit geostatistical GLMMs.",
  booktabs = TRUE,
  linesep = c(
    rep('', 4), # coefs
    '\\addlinespace',
    rep('', 6), # correlation stuff
    '\\addlinespace',
    rep('', 12), # likelihood
    '\\addlinespace',
    rep('', 2), # bayes
    '\\addlinespace'
  ),
  escape = FALSE, row.names = FALSE) %>%
  kableExtra::kable_styling(font_size = 8) %>%
  kableExtra::footnote(
    general = paste(
      "$^1$Technically possible but non-trivial.",
      "$^2$Penalized smoother GAMs that determine `wiggliness'.",
      "$^3$inlabru but not INLA.",
      "$^4$Spatiotemporal fields as random walk only.",
      "$^5$SPDE approach as in Miller et al. (2019).",
      "$^6$Does have predictive process knots.",
      "$^7$Zero-inflated NB2 only.",
      "$^8$Tweedie power parameter fixed for \\\\texttt{mgcv::gamm()}.",
      "$^9$Possible as log-linked Poisson GLMM with aggregated data.",
      "$^{10}$Hurdle models possible by fitting components separately."
    ),
    escape = FALSE, threeparttable = TRUE
  )
@

\begin{table}

\centering
\fontsize{8}{10}\selectfont
\begin{threeparttable}
\begin{tabular}[t]{lllllll}
\toprule
 & \pkg{sdmTMB} & \pkg{VAST} & \proglang{R}-\pkg{INLA}/\pkg{inlabru} & \pkg{mgcv} & \pkg{spBayes} & \pkg{spaMM}\\
\midrule
Time-varying coefficients & \checkmark & --$^1$ & \checkmark & \checkmark & \checkmark & --\\
Spatially varying coefficients (SVC) & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark & --\\
GAMs$^2$ & \checkmark & -- & \checkmark & \checkmark & -- & --\\
Threshold covariates & \checkmark & -- & \checkmark$^3$ & -- & -- & --\\
Offsets & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark\\
\addlinespace
Spatiotemporal fields & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark$^4$ & --\\
Spatial + spatiotemporal fields & \checkmark & \checkmark & \checkmark & \checkmark & -- & --\\
Anisotropy & \checkmark & \checkmark & -- & \checkmark & -- & --\\
Correlation barriers & \checkmark & \checkmark & \checkmark & \checkmark & -- & --\\
Separate range parameters for fields & \checkmark & -- & \checkmark & \checkmark & -- & --\\
Share range parameters across fields & \checkmark & \checkmark & \checkmark & -- & -- & --\\
SPDE-based & \checkmark & \checkmark & \checkmark & \checkmark$^5$ & --$^6$ & \checkmark\\
\addlinespace
NB1 distribution & \checkmark & -- & \checkmark & \checkmark & -- & \checkmark\\
NB2 distribution & \checkmark & \checkmark$^7$ & \checkmark & \checkmark & -- & \checkmark\\
Zero-truncated distributions & \checkmark & -- & \checkmark & -- & -- & \checkmark\\
Zero-inflated distributions & \checkmark & \checkmark & \checkmark & -- & -- & \checkmark\\
Tweedie distribution & \checkmark & \checkmark & \checkmark & \checkmark$^8$ & -- & --\\
Student-t distribution & \checkmark & -- & \checkmark & \checkmark & -- & --\\
Censored Poisson distribution & \checkmark & -- & \checkmark & -- & -- & --\\
log Gaussian Cox processes & --$^9$ & --$^9$ & \checkmark & --$^9$ & --$^9$ & --$^9$\\
Multivariate responses & -- & \checkmark & \checkmark & -- & \checkmark & \checkmark\\
Built-in delta/hurdle models & \checkmark & \checkmark & \checkmark & --$^{10}$ & -- & \checkmark\\
Poisson-link delta models & \checkmark & \checkmark & \checkmark & -- & -- & --\\
Likelihood weights & \checkmark & -- & \checkmark & \checkmark & \checkmark & \checkmark\\
Maximum/marginal likelihood & \checkmark & \checkmark & -- & \checkmark & -- & --\\
\addlinespace
Bayesian/optionally Bayesian & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark & --\\
Priors/penalties & \checkmark & -- & \checkmark & -- & \checkmark & --\\
Matern PC priors & \checkmark & -- & \checkmark & -- & -- & --\\
\addlinespace
Spatial (or spatial dynamic) factor analysis & -- & \checkmark & -- & -- & -- & --\\
Empirical Orthogonal Function (EOF) analysis & -- & \checkmark & -- & -- & -- & --\\
Built-in area-weighted index standardization & \checkmark & \checkmark & -- & -- & -- & --\\
Built-in cross-validation & \checkmark & -- & -- & -- & -- & --\\
\bottomrule
\end{tabular}
\end{threeparttable}
\label{tab:functionality}

\caption{Comparison of functionality between several \proglang{R} packages that can fit geostatistical GLMMs.
Notes:
$^1$Technically possible but non-trivial.
$^2$Penalized smoother GAMs that determine `wiggliness'.
$^3$\pkg{inlabru} but not \proglang{R}-\pkg{INLA}.
$^4$Spatiotemporal fields as random walk only.
$^5$SPDE approach as in \citet{miller2019}.
$^6$Does have predictive process knots.
$^7$Zero-inflated NB2 only.
$^8$Tweedie power parameter fixed for \texttt{mgcv::gamm()}.
$^9$Possible as log-linked Poisson GLMM with aggregated data.
$^{10}$Hurdle models possible by fitting components separately.
}
\end{table}

<!-- TODO: Line 242. Can \pkg{sdmTMB} be run in parallel? If so, does the parallelism share memory across the cores or does the memory grow with the number of cores? This is a HUGE feature of PARDISO within \proglang{R}-\pkg{INLA}/\pkg{inlabru} allowing for very large models to be fit on HPCs. It might be worth mentioning and adding to Table 1. Also Line 242: do you expect the same relative performance between the software packages as more cores are used? -->

We ran a simple speed comparison between \pkg{sdmTMB}, \proglang{R}-\pkg{INLA}/\pkg{inlabru}, and \pkg{mgcv} for fitting an SPDE spatial random field model to 1000 data points with Gaussian error across a range of mesh resolutions (Figure \ref{fig:timing}, Appendix \ref{app:speed}).
In this test, \pkg{sdmTMB} was the fastest across all mesh resolutions; however, \proglang{R}-\pkg{INLA}/\pkg{inlabru} and \pkg{spaMM} were less affected by mesh resolution than \pkg{sdmTMB}.
\pkg{mgcv} was most affected by mesh resolution.
Our test was restricted to one core and default \proglang{R} algebra libraries; all packages could run faster with optimized libraries and parallel processing.
Results with optimized math libraries on one core (\pkg{openBLAS}: @openblas and \pkg{PARDISO}: @pardiso7.2a) resulted in a ~10% speed increase for \pkg{sdmTMB} and \pkg{inlabru} and a ~7--9-fold speed increase for \pkg{mgcv}.

\begin{figure}[htb]
\centering
\includegraphics[width=3.5in]{../../figs/timing-spatial-2023-03-16-xkcd.pdf}
\caption[]{Comparison of time to fit an SPDE spatial random field model with 1000 observations, an intercept and one predictor, Gaussian error, and a sequence of SPDE resolutions. Lines represent means and ribbons 95\% quantiles across 50 random iterations. Note the log-distributed x axis. \pkg{VAST} should be similar to \pkg{sdmTMB} and so is not shown. \pkg{inlabru} used the empirical Bayes integration strategy and Gaussian approximation with \texttt{bru\_max\_iter = 1}, and the \texttt{like()} formulation. \pkg{mgcv} used \texttt{bam()}, \texttt{method = `fREML'}, and discretized covariates \citep{miller2019}. Note that \pkg{spaMM} only fits spatial, not spatiotemporal, models. All platforms were restricted to one core and could be faster with parallel computation or optimized algebra libraries.}\label{fig:timing}
\end{figure}


# Installation

\pkg{sdmTMB} can be installed from the Comprehensive \proglang{R} Archive
Network (CRAN) at <https://CRAN.R-project.org/package=sdmTMB>

<<sdmTMB-install, eval=FALSE, echo=TRUE>>=
install.packages("sdmTMB", dependencies = TRUE)
@

Importantly, `dependencies = TRUE` includes the \proglang{R}-INLA package
[@rue2009; @lindgren2011; @lindgren2015], which is not on CRAN but is needed
for the `make_mesh()` function below. Soon, we intend to switch to using the
\pkg{fmesher} package to eliminate this dependency.

Alternatively, the development version can be installed with:

<<remotes, eval=FALSE, echo=TRUE>>=
# install.packages("remotes")
remotes::install_github("pbs-assess/sdmTMB", dependencies = TRUE)
@

Additional utilities are maintained in the \pkg{sdmTMBextra} package at
<https://github.com/pbs-assess/sdmTMBextra>.

# Species distribution modelling with spatial random fields

We begin with a simple species distribution model of encounter probability of
Pacific Cod (*Gadus macrocephalus*) from a trawl survey conducted in Queen
Charlotte Sound, British Columbia, Canada. The purpose of our example is to
illustrate the need for spatial random fields. This survey is conducted by
Fisheries and Oceans Canada (REF) and follows a depth-stratified random
sampling design, resulting in a georeferenced dataset. The data frame `pcod` is
available as package data in \pkg{sdmTMB}. Relevant columns include latitude,
longitude, Universal Transverse Mercator (UTM) coordinates, bottom
depth, and encounter (`present = 1`) vs. non-encounter (`present = 0`).

<<libs, warning=FALSE, message=FALSE, echo=TRUE, cache=FALSE>>=
library(sdmTMB)
library(dplyr)
library(ggplot2)
@

<<setoptions, echo=FALSE>>=
options(
  pillar.print_max = 3,
  pillar.print_min = 3,
  pillar.advice = FALSE,
  pillar.width = 80
)
options(width = 80)
@

<<libs-extras>>=
theme_set(theme_light())
options(ggplot2.continuous.fill = "viridis")
@


<<pcod-head, echo=TRUE>>=
select(pcod, lat, lon, X, Y, depth, present) |> 
  head()
@

An \pkg{sdmTMB} model requires a data frame that contains a response column,
columns for any predictors, and columns for spatial coordinates. Usually it
makes sense to convert the spatial coordinates to an equidistant projection
such as UTMs to ensure that distance remains constant throughout the study
region [e.g., using `sf::st_transform()`, @pebesma2018]. Here we use the helper
function `add_utm_columns()` to add UTM coordinates with km units (so our
estimated spatial range parameter is not too big or small). By default, the
function will guess the UTM zone and create new columns `X` and `Y`. Since our
example data already has these UTM columns, we can skip running this code.

<<pcod-utms-eval, echo=TRUE, eval=FALSE>>=
pcod <- add_utm_columns(pcod, c("lon", "lat"), units = "km")
@

\sloppy
We then create a mesh object that contains triangulation and projection
matrices needed to apply the SPDE approach. Here, `cutoff` defines the minimum
allowed distance between mesh vertices in the units of `X` and `Y`.
`make_mesh()` is a wrapper function for `INLA::inla.mesh.create()` or
`fmesher::fm_rcdt_2d_inla()` and `cutoff` is passed through to these functions.
Alternatively, we could have created any mesh via \proglang{R}-\pkg{INLA} or
\pkg{fmesher} and supplied it to the `mesh` argument in `make_mesh()`. We can
inspect our mesh object with the associated plotting method. Our mesh has `r mesh_pcod$mesh$n` (`mesh_pcod$mesh$n`) vertices.
 

<<dog-binomial-mesh, results='hide', message=FALSE, warning=FALSE, echo=TRUE, fig.cap="SPDE mesh (lines) combined with the trawl survey observations (points). The locations where lines intersect are referred to as ``vertices''. Finer meshes will be slower to fit but generally increase the accuracy of the SPDE approximation. This is a simple mesh created with the convenience function \\code{make\\_mesh()}. A greater degree of control over the mesh construction can be achieved by using the \\pkg{fmesher} or \\proglang{R}-\\pkg{INLA} directly.", fig.width=5>>=
mesh_pcod <- make_mesh(pcod, xy_cols = c("X", "Y"), cutoff = 8)
plot(mesh_pcod)
@

We can then fit our model with `sdmTMB()`. We will fit a logistic regression of
encounter probability with and without spatial random fields (by toggling the
`spatial` argument) to illustrate the importance of accounting for spatial
correlation. In addition to the spatial random field, we include an intercept
and a quadratic effect of depth on the probability of encounter. The `update()`
S3 method refits the same model updating any specified arguments.

Our random field model can be written as

$$
\begin{aligned}
y_{\bm{s}} &\sim \operatorname{Bernoulli} \left(\mu_{\bm{s}}\right),\\
\mu_{\bm{s}} &= \operatorname{logit}^{-1} \left( \bm{X}^{\mathrm{main}}_{\bm{s}} \bm{\beta} +
\omega_{\bm{s}}
\right),
\end{aligned}
$$

where $\bm{X}^{\mathrm{main}}_{\bm{s}}$ contains main effect covariates (intercept, quadratic effects of depth), $\bm{\beta}$ represents estimated main effect coefficients, and $\omega_{\bm{s}}$ represents the estimated spatial field, 

$$
\omega_{\bm{s}} \sim \mathrm{MVN}(\bm{0},\bm{\Sigma}_\omega)
$$

<<pcod-fit, echo=TRUE>>=
fit_bin_rf <- sdmTMB(
  present ~ poly(log(depth), 2),
  data = pcod, mesh = mesh_pcod, 
  spatial = "on",
  family = binomial(link = "logit")
)
fit_bin <- update(fit_bin_rf, spatial = "off")
@

We can run some basic checks on our model with the `sanity()` function:

<<pcod-eg1-sanity, eval=TRUE, echo=TRUE, message=FALSE>>=
sanity(fit_bin_rf)
@

```
#> ✓ Non-linear minimizer suggests successful convergence
#> ✓ Hessian matrix is positive definite
#> ✓ No extreme or very small eigenvalues detected
#> ✓ No gradients with respect to fixed effects are >= 0.001
#> ✓ No fixed-effect standard errors are NA
#> ✓ No fixed-effect standard errors look unreasonably large
#> ✓ No sigma parameters are < 0.01
#> ✓ No sigma parameters are > 100
#> ✓ Range parameter doesn't look unreasonably large
```

Here, this does not flag any issues. `sanity()` is checking that the `nlminb()`
optimizer reported successful convergence, that the Hessian matrix is positive
definite, that no extreme or small eigenvalues are detected, that no
absolute log likelihood gradients with respect to fixed defects are >= 0.001,
that all fixed effects have reported standard errors that do not look
unreasonably large (< 100 by default), that random field marginal standard
deviations are not unexpectedly small or large (> 0.01 and < 100), and that the random field
Matérn range parameter does not look unreasonably large (< 1.5 times the largest edge of a bounding box around the observations).

We can get a summary of our model fit:

<<pcod-bin-summary, echo=TRUE>>=
summary(fit_bin_rf)
@

The output indicates our model was fit by maximum (marginal) likelihood (`ML`).
We also see the formula, mesh, fitted data, and family. Next we see any
estimated main effects, the Matérn range distance, the spatial random field
standard deviation, and the negative log likelihood at convergence. 

<!-- The -->
<!-- smoother summary follows the format used in the \pkg{brms} package -->
<!-- [@burkner2017]. As noted in the print method, we can extract a tidy data frame -->
<!-- similar to the format in the \pkg{broom} [@broom] and \pkg{broom.mixed} -->
<!-- [@broommixed] packages: -->

```{r}
# set.seed(1)
# pcod$resid_bin <- residuals(fit_bin)
# set.seed(1)
# pcod$resid_bin_rf <- residuals(fit_bin_rf)
# g1 <- ggplot(pcod, aes(X, Y, colour = resid_bin)) + geom_point() +
#   scale_color_gradient2() +
#   theme(legend.position = "bottom")
# g2 <- ggplot(pcod, aes(X, Y, colour = resid_bin_rf)) + geom_point() +
#   scale_color_gradient2() +
#   theme(legend.position = "bottom")
# cowplot::plot_grid(g1, g2, ncol = 2)
```

```{r, echo=FALSE, results='hide'}
test_autocor <- function(obj) {
  set.seed(1)
  s <- simulate(obj, nsim = 500)
  pr <- predict(obj, type = "response")$est
  r <- DHARMa::createDHARMa(
    simulatedResponse = s,
    observedResponse = pcod$present,
    fittedPredictedResponse = pr
  )
  DHARMa::testSpatialAutocorrelation(r, x = pcod$X, y = pcod$Y, plot = FALSE)
}
(t_no_rf <- test_autocor(fit_bin))
(t_rf <- test_autocor(fit_bin_rf))
p_rf <- round(t_rf$p.value, 2)
```

We can test for spatial autocorrelation with a Moran's I test or with a visual
inspection of the residuals calculated from the `residuals()` S3 method. We
omit example code for Moran's I calculation for brevity but include it in the
code supplement. The p-value for spatial autocorrelation is low for the model
without a random field (p < 0.01) but large for the model with a random field
(p = `r p_rf`) suggesting significant residual correlation in the simpler model
that is alleviated by including the random field. 

We can also see that the AIC of the model with spatial random fields is
considerably lower:

<<pcod-aic, eval=TRUE, echo=TRUE, results='markup'>>=
AIC(fit_bin_rf, fit_bin)
@

We could do additional testing with cross validation via `sdmTMB_cv()`. Here we
will do 10-fold cross validation with the folds constructed randomly. Using the
`fold_ids` argument, we could supply our own folds and conduct spatially
blocked cross validation.

<<pcod-cv, eval=TRUE, echo=TRUE>>=
cv_bin_rf <- sdmTMB_cv(present ~ poly(log(depth), 2),
  data = pcod, mesh = mesh_pcod, spatial = "on",
  family = binomial(), k_folds = 10
)
cv_bin <- sdmTMB_cv(present ~ poly(log(depth), 2),
  data = pcod, mesh = mesh_pcod, spatial = "off",
  family = binomial(), k_folds = 10
)
@

Indeed, the log likelihood of left-out data is considerably larger for the
model that includes random fields:

<<pcod-cv-out, eval=TRUE, echo=TRUE, results='markup'>>=
cv_bin_rf$sum_loglik
cv_bin$sum_loglik
@

The standard errors on our fixed effects have increased with the spatial random
field:

<<pcod-tidy, eval=TRUE, echo=TRUE, results='markup'>>=
tidy(fit_bin_rf, conf.int = TRUE)
tidy(fit_bin, conf.int = TRUE)
@

We can also use `tidy()` to get a data frame of our random field parameters,
where `sigma_O` is $\sigma_O$ in the above equations---the standard deviation of
the spatial random field $\bm{\omega}$.

<<pcod-eg1-tidy-re, eval=TRUE, echo=TRUE>>=
tidy(fit_bin_rf, effects = "ran_pars", conf.int = TRUE)
@

\sloppy
To visualize our model, we can make predictions with the `predict()` method
(`?predict.sdmTMB`) and optionally use the `newdata` argument to predict on
a new data frame with any locations and values for the predictor columns. Here,
we will predict on a 2 $\times$ 2 km grid (`qcs_grid`) that covers the entire
region of interest so we can visualize the predictions spatially. The grid
contains spatial covariate columns and all predictors used in the model set at
values for which we want to predict. The output of `predict()` is a data frame
containing overall estimates in link space (`est`), estimates from the
non-random-field components (`est_non_rf`; here, intercept and depth), and
estimates from the individual random field components (here, `omega_s`---the
spatial field).

<<pcod-predict, echo=TRUE, results='markup'>>=
p <- predict(fit_bin_rf, newdata = qcs_grid)
select(p, X, Y, depth, est, est_non_rf, omega_s) |>
  as_tibble() |> head(n = 2)
@

<<pcod-predict-maps, fig.width=10, fig.asp=0.4, out.width="6.1in", fig.cap="Prediction components from the binomial species distribution model of Pacific Cod. Shown are (a) the quadratic effect of bottom depth, (b) the spatial random field in link space, and (c) the overall prediction, which here is the combination of panels a and b. Note the difference between only the fixed effects (a) and including the spatial random field (c).">>=
plot_spatial_map <- function(dat, column, title) {
  ggplot(dat, aes(X, Y, fill = {{ column }})) +
    geom_raster() +
    coord_fixed() +
    theme(legend.position= "bottom") +
    ggtitle(title) +
    theme(axis.title = element_blank(), axis.ticks = element_blank(), axis.text = element_blank())
}
g1 <- plot_spatial_map(p, plogis(est_non_rf), "(a) Fixed effects")
g2 <- plot_spatial_map(p, omega_s, "(b) Spatial random field") +  scale_fill_gradient2()
g3 <- plot_spatial_map(p, plogis(est), "(c) Combined prediction")
cowplot::plot_grid(g1, g2, g3, ncol = 3)
@

# Spatiotemporal species distribution modeling with dogfish

<!-- Need brief description of dogfish data and model here?? -->

As a second example, we will construct a spatiotemporal model of catch rates of
Pacific Spiny Dogfish (*Squalus suckleyi*) from a trawl survey off the west
coast of Vancouver Island, Canada. This example extends the spatial model
described above by also including (1) spatiotemporal fields allowing the
distribution in each year to be unique, (2) a time-varying intercept as an
AR(1) process to allow year effects to vary but remain autocorrelated, (3)
a smooth effect of depth, allowing catch rates to vary non-linearly with
depth, and (4) spatial anisotropy allowing spatial correlation to be directionally
dependent. Since catch rates are positive, continuous, and contain zeros, we begin
by specifying the response family as a Tweedie distribution [@tweedie1984] with
a log link. We then compare alternative families, spatiotemporal random field
structures, and the exclusion of anisotropy to illustrate the flexibility of
\pkg{sdmTMB}.

<!-- We can then fit a model with spatial random fields (`spatial = "on"`) via the function `sdmTMB()`. -->
<!-- We use a penalized smoother for depth as a main effect via `s()` from the \pkg{mgcv} package. -->
<!-- We specify the family as Tweedie [@tweedie1984] to account for positive continuous density values that also contain zeros. -->
<!-- An alternative would be the `delta_gamma()` family [@aitchison1955] or to model catch weight with an offset for log(area swept) (via the `offset` argument). -->

The dataset includes spatial coordinates, year, dogfish catch weight in kg,
area swept in km, and bottom depth:

<<dog-head-dat, echo=TRUE>>=
dat <- select(dogfish, lon = longitude, lat = latitude, year, 
  catch_weight, area_swept, depth) |> as_tibble()
head(dat)
@

We add UTM zone 9 columns, create a log depth column for convenience, and
create a basic mesh:

<<dog-utms, echo=TRUE>>=
dat <- add_utm_columns(dat, c("lon", "lat"), 
  units = "km", utm_crs = 32609)
dat$log_depth <- log(dat$depth)
mesh <- make_mesh(dat, xy_cols = c("X", "Y"), cutoff = 8)
@

<<dog-mesh2, eval=FALSE>>=
plot(mesh)
@

We can then specify our model. We include an offset for the effort variable log
area swept such that we are effectively modelling density and our predictions
will be for an area swept of 1 km^2^.

Our model can be written as TODO

$$
\begin{aligned}
\mathbb{E}[y_{\bm{s},t}] &= \mu_{\bm{s},t},\\
\mu_{\bm{s},t} &=
\exp \left( \bm{X}^{\mathrm{main}}_{\bm{s},t} \bm{\beta} +
O_{\bm{s},t} +
\bm{X}^{\mathrm{tvc}}_{\bm{s},t} \gamma_t +
\omega_{\bm{s}} +
\epsilon_{\bm{s},t} 
\right),
\end{aligned}
$$

where $\bm{\beta}$ are coefficients associated with the main effects, $O_{\bm{s},t}$ represents the offset (here, log area swept), $\gamma_t$ represents the time-varying coefficients, $\omega_{\bm{s}}$ is the spatial field (equivalent to a spatial intercept) and $\epsilon_{\bm{s},t}$ represents spatiotemporal fields.

The temporally varying intercepts $\gamma_t$ are modeled as a stationary AR(1) process,

$$
\begin{aligned}
  \gamma_{t=1} &\sim \operatorname{Normal} \left(0, \sigma^2_{\gamma} \right),\\
  \gamma_{t>1} &\sim \operatorname{Normal} \left(\rho_\gamma\gamma_{t-1}, \sqrt{1 - \rho_\gamma^2} \sigma^2_{\gamma} \right).
\end{aligned}
$$

<<dog-tw, results='hide', message=FALSE, warning=FALSE, echo=TRUE>>=
fit_tw <- sdmTMB(
  catch_weight ~ s(log_depth),
  data = dat,
  mesh = mesh,
  offset = log(dat$area_swept),
  time = "year",
  time_varying = ~ 1,
  time_varying_type = "ar1",
  spatial = "on",
  spatiotemporal = "iid",
  anisotropy = TRUE,
  silent = FALSE,
  family = tweedie()
)
@

We can explore four alternative families that may better represent the data.
Each alternative family uses a delta or hurdle distribution: delta-gamma and
delta-lognormal (REF), and delta-Poisson-link-gamma and
delta-Poisson-link-lognormal (REF). The Poisson-link models depart from the conventional delta models in treating the probability of occurrence at a given location ($p_i$) as a Poisson process rather than a Bernoulli one, $p_i = 1 - exp(a_i * n_i)$, where $n_i$ is the total number of individuals available to be encountered, and $a_i$ is a measure of sampling effort [@thorson2018_poissonlink]. Note that we choose to omit the
spatiotemporal random fields from the binomial model component 
(`spatiotemporal = list("off", "iid")`) because initial fits indicated this random field was
collapsing to zero indicating minimal changes in encounter spatial distribution
from year to year.

<!-- TODO EQUATIONS NEED TO INTRO THE POISSON LINK AS BRIEFLY AS POSSIBLE. SEE sdmTMB VIGNETTE. -->

<<dog-update, results='hide', message=FALSE, warning=FALSE, echo=TRUE>>=
fit_dg <- update(fit_tw, family = delta_gamma(), 
  spatiotemporal = list("off", "iid"))
fit_dl <- update(fit_dg, family = delta_lognormal())
fit_dpg <- update(fit_dg, family = delta_poisson_link_gamma())
fit_dpl <- update(fit_dg, family = delta_poisson_link_lognormal())
@

We can then compare the models via AIC:

<<dog-aic, echo=TRUE>>=
AIC(fit_tw, fit_dg, fit_dl, fit_dpg, fit_dpl) |> 
  mutate(delta_AIC = AIC - min(AIC)) |> 
  arrange(delta_AIC)
@

We find that the Poisson-link delta-lognormal model is favoured with AIC. We
next test two additional model formulations: making the spatial correlation
isotropic (the default) instead of anisotropic, and structuring the positive
model component spatiotemporal random fields as AR(1) to allow spatiotemporal
hotspots to persist from year to year.

The AR(1) fields can be represented as TODO.

$$
\begin{aligned}
\bm{\delta}_{t=1} &\sim \operatorname{MVN} (\bm{0}, \bm{\Sigma}_{\epsilon}),\\
\bm{\delta}_{t>1} &= \rho \bm{\delta}_{t-1} + \sqrt{1 - \rho^2} \bm{\epsilon_{t}},  \:
\bm{\epsilon_{t}} \sim \operatorname{MVN} \left(\bm{0}, \bm{\Sigma}_{\epsilon} \right),
\end{aligned}
$$ 

where $\rho$ represents the estimated autoregressive parameter allowing the spatial field at time $t$ to be correlated with the spatial field at time $t-1$.

<<dog-ar1, results='hide', echo=TRUE>>=
fit_dpl_iso <- update(fit_dpl, anisotropy = FALSE)
fit_dpl_ar1 <- update(fit_dpl, spatiotemporal = list("off", "ar1"))
@

<<dog-aci2, echo=TRUE>>=
AIC(fit_dpl_ar1, fit_dpl, fit_dpl_iso)
@

<!-- Need description of anisotropy and why it's important here or somewhere
else --> 

We find that the anisotropic AR(1) is favoured. It makes sense that anisotropy
is important here given the elongated shape of the continental shelf with
a rapid transition to deeper water. On inspecting the model output with
`summary()`, we notice that the spatial random field SD in the positive model
component has become very small once AR(1) spatiotemporal fields were added. We
therefore consider a model where these are turned off in the second component
of the delta model:

<<dog-ar1-2, echo=TRUE, results="hide">>=
fit_dpl_ar1_only <- update(fit_dpl_ar1, spatial = list("on", "off"))
@

<<dog-aic3, echo=TRUE>>=
AIC(fit_dpl_ar1_only, fit_dpl_ar1, fit_dpl)
@

We save our chosen model to the object `fit` to simplify subsequent code, run
the `sanity()` check (suppressed for space), and inspect `summary()`:

<<dog-print, echo=TRUE>>=
fit <- fit_dpl_ar1_only
sanity(fit)
summary(fit)
@

The output is considerably more complex compared to our binomial spatial model.
We now have two model components, which are shown one after the other. Starting
with the binomial component, we have output from the smoother, which includes
a linear component (`slog_depth`) and the standard deviation on the smoother
weights (`sds(log_depth)`). The smoother summary follows the format used in the
\pkg{brms} package [@burkner2017]. Next, we have the time-varying intercepts
and information on our anisotropic spatial correlation. We then have the second
model component (lognormal) with a similar summary structure but with the
addition of a dispersion parameter for the lognormal, the AR(1) correlation of
the spatiotemporal random fields, and a spatiotemporal random field marginal
standard deviation. We can use `plot_anisotropy()` to visually inspect the
anisotropy (Figure \ref{fig:dog-aniso}).

(ref:dog-aniso)

<<dog-aniso, echo=TRUE, fig.cap= "A visualization of anisotropy from the function \\code{plot\\_anisotropy()}. Ellipses are centered at coordinates of zero in the space of the X-Y coordinates being modeled. The ellipses show the spatial and spatiotemporal range (distance at which correlation is effectively independent) in any direction from zero.", out.width="4in">>=
plot_anisotropy(fit)
@

Similarly to the first example, we can visualize model predictions on a grid
covering the area of interest. Because this is a spatiotemporal model, we first
need to replicate our grid for each year we will predict on. Since this is
a common operation, we include the convenience function `replicate_df()` to
replicate a data frame. We then ensure our data frame contains all the
predictors used in the model (here `log_depth`).

<!-- Propose moving this to a short paragraph `Prediction` to highlight modularity -->
<<dog-grid, echo=TRUE>>=
grid <- replicate_df(wcvi_grid, "year", time_values = unique(dat$year))
grid$log_depth <- log(grid$depth)
head(grid, n = 2)
@

<<dog-pred1, echo=TRUE>>=
pred <- predict(fit, newdata = grid, type = "response")
@

<<dog-pred2, echo=TRUE>>=
names(pred)
@

Our prediction data frame is similar to the binomial spatial model, but includes
columns for the two delta model components (labelled with suffixes `1` and `2`)
and adds an `epsilon_st` column for spatiotemporal random effects. We can easily
generate plots from this data frame (e.g., with `ggplot2::geom_raster()`). We
suppress that code in this paper for brevity.

<<plot-map, echo=FALSE>>=
plot_map <- function(dat, column) {
  ggplot(dat, aes(X, Y, fill = {{ column }})) +
    geom_raster() +
    facet_wrap(vars(year)) +
    coord_fixed() +
    theme(legend.position= "bottom") +
    theme(axis.title = element_blank(), axis.ticks = element_blank(), axis.text = element_blank())
}
@

<<dog-plot1, echo=FALSE>>=
g_nonrf <- pred |> filter(year %in% c(2004, 2022)) |> 
  plot_map(est_non_rf1) +
  scale_fill_viridis_c(trans = "log10") +
  ggtitle("(a) Non-random-field components; first delta model")
@

<<dog-plot2, echo=FALSE>>=
g_omega <- pred |> filter(year %in% c(2004, 2022)) |> 
  plot_map(omega_s1) +
  scale_fill_gradient2() +
  ggtitle("(b) Spatial random field; first delta model")
@

<<dog-plot3, echo=FALSE>>=
g_eps <- pred |> filter(year %in% c(2004, 2022)) |> 
  plot_map(epsilon_st2) +
  scale_fill_gradient2() +
  ggtitle("(c) Spatiotemporal random field; second delta model")
@

<<dog-plot4, echo=FALSE>>=
g_est <- pred |> filter(year %in% c(2004, 2022)) |> 
  plot_map(est) +
  # labs(fill = "Density") +
  scale_fill_viridis_c(trans = "log10") +
  ggtitle("(d) Overall prediction")
@

```{r dog-wvci-pred, fig.asp = 0.8, fig.cap="Example prediction components from the spatiotemporal model of Pacific Dogfish biomass density. Throughout, two example years are shown. \\code{est\\_non\\_rf1} refers to the prediction from all non-random-field components (here, a smoother for bottom depth and the time-varying year effect) from the first delta model, \\code{omega\\_s1} refers to the spatial random field from the first delta model, \\code{epsilon\\_st2} refers to spatiotemporal random fields from the second delta model, and \\code{est} refers to the overall prediction estimate combining all effects. The spatial random field is constant through time and represents static biotic or abiotic features not included as covariates (e.g. habitat). The spatiotemporal random fields are different each time step and here are allowed to follow an AR(1) process. They represent temporal variability in the spatial patterning of Pacific Dogfish (resulting from movement, local changes in population densities, etc).", fig.width=9, out.width="6in"}
cowplot::plot_grid(
  g_nonrf,
  g_omega,
  g_eps,
  g_est,
  ncol = 2L
)
@

We can visualize the conditional effect of the bottom depth smoother by
predicting across a sequence of depths and holding other variables at reference
values (Figure \ref{fig:dog-depth-plot}). Here, we pick the last year, specify
to include both delta model components (`model = NA`), omit the random fields
(`re_form = NA`), and return standard errors (`se_fit = TRUE`).

<<dog-depth, echo=TRUE, out.width="5in">>=
nd <- data.frame(
  log_depth = seq(min(dat$log_depth), max(dat$log_depth), length.out = 100), 
  year = max(dat$year)
)
pred_depth <- predict(
  fit, newdata = nd, 
  model = NA, re_form = NA, se_fit = TRUE
)
@

<<dog-depth-plot, echo=FALSE, fig.cap="TODO", out.width="4in">>=
ggplot(pred_depth, aes(
  exp(log_depth), exp(est), 
  ymin = exp(est - 2 * est_se), 
  ymax = exp(est + 2 * est_se))) +
  geom_ribbon(fill = "grey90") +
  geom_line() +
  scale_y_continuous(expand = expansion(mult = c(0, 0.03)), limits = c(0, NA)) +
  labs(x = "Depth (m)", y = "Density")
@

We can generate an area-weighted population index (e.g., a relative or absolute
index of abundance or biomass) that is independent of sampling locations by
predicting from the model on a grid covering the area of interest and summing
the predicted biomass with the `get_index()` function (Figure
\ref{fig:dog-index-plot}). We supply the grid cell area (4 km^2^) to the `area`
argument and specify `bias_correct = TRUE` to enable a generic epsilon-bias
correction needed due to the non-linear transformation of the random effects
(REF).
<!-- TODO: and the Laplace? -->

<<dog-index, echo=TRUE>>=
pred2 <- predict(fit, newdata = grid, return_tmb_object = TRUE)
ind <- get_index(pred2, bias_correct = TRUE, area = rep(4, nrow(grid)))
@

<<dog-index-plot, echo=FALSE, fig.cap="TODO", out.width="4in">>=
ggplot(ind, aes(year, est, ymin = lwr, ymax = upr)) +
  geom_pointrange() +
  scale_y_continuous(expand = expansion(mult = c(0, 0.03)), limits = c(0, NA)) +
  labs(y = "Biomass", x = "Year")
@

\clearpage

# Spatially varying coefficient example with citizen science data

In our final example, we demonstrate a model with spatially varying coefficient
(SVC) effects and illustrate combining uncertainty from parameters by working
with draws from the joint parameter precision matrix. Spatially varying
coefficients ... TODO REFS. In addition, we illustrate using restricted maximum
likelihood (REML), which integrates over the fixed effects as well as the
random effects.

Snowy Owls (*Bubo scandiacus*) breed on the arctic tundra and are irruptive
migrants, meaning that they appear across the mid-latitudes of North America in
much greater numbers in some winters than others. The reasons for this
interannual variation in the number of individuals migrating south are not well
understood but seem to be related to high abundances of food during the
breeding season and therefore sharp increases in breeding ground population
densities [@robillard2016]. The North Atlantic Oscillation Index (NAO) has been
linked to productivity of both owls and their prey in Europe [@millon2014].
Because both productivity and the choice of wintering location could be
influenced by climate, we modelled a spatially varying effect of annual mean
NAO index on winter abundance across the southern boundary of their winter
distribution. We fit counts observed in North America during annual Christmas
Bird Counts [@cbc] using a negative binomial [NB2, @hilbe2011] distribution,
random intercepts for year, spatial and spatiotemporal random fields, and
a spatially varying coefficient associated with the NAO.

We can write the model as

$$
\begin{aligned}
\mathbb{E}[y_{\bm{s},t}] &= \mu_{\bm{s},t},\\
\mu_{\bm{s},t} &=
\exp \left( \bm{X}^{\mathrm{main}}_{\bm{s},t} \bm{\beta} +
\alpha_g +
\bm{X}^{\mathrm{svc}}_{\bm{s},t} \zeta_{\bm{s}} +
\omega_{\bm{s}} +
\epsilon_{\bm{s},t} \right),
\end{aligned}
$$

where three spatial fields are now estimated: the spatial intercept ($\omega_{\bm{s}}$), spatiotemporal variation ($\epsilon_{\bm{s},t}$), and spatially varying NAO coefficients ($\zeta_{\bm{s}}$).

<<owl-data>>=
snow <- readRDS(here::here("data/SNOW_data.rds"))
@

<<owl-fit, echo=TRUE, results = "hide">>=
mesh_snow <- make_mesh(snow, xy_cols = c("X", "Y"), cutoff = 1.5)
fit_owl <- sdmTMB(
  count ~ 1 + nao + (1 | year_f),
  spatial_varying = ~ nao,
  time = "year",
  data = snow, 
  family = nbinom2(link = "log"),
  spatial = "on",
  spatiotemporal = "iid",
  mesh = mesh_snow,
  reml = TRUE,
  silent = FALSE
)
@

<<owl-sanity, eval=FALSE>>=
sanity(fit_owl)
@

<<owl-print, echo=TRUE>>=
summary(fit_owl)
@

The spatially varying coefficient effect at any point in space is the
combination of the main effect and spatial random effect for `nao`. We
illustrate deriving uncertainty on their combination by simulating from the
parameter precision matrix assuming the joint parameter covariance matrix in
multivariate normal. We do this by specifying a non-null number of simulation
draws to `nsim` in `predict.sdmTMB()`. By default, `nsim > 0` will return
a matrix of draws from the overall prediction. Here, we instead specify that we
want to return draws from the `zeta_s` random field, which is the spatially
varying random field. This returns a matrix where each row matches a row of
`newdata` and each column is a simulation draw. We then use the function
`spread_sims()` to draw 200 simulations from the parameters themselves, combine
the main effect draws (`sims$nao`) with the random field values `zeta_s`, and
calculate the median for each row of data so we can plot them.

<<p-mean, message=FALSE, echo=TRUE, eval=TRUE, cache=TRUE>>=
zeta_s <- predict(fit_owl, newdata = snow, nsim = 200, sims_var = "zeta_s")
dim(zeta_s)
sims <- spread_sims(fit_owl, nsim = 200)
combined <- sims$nao + t(zeta_s)
snow$nao_effect <- apply(exp(combined), 2, median)
@

We can make a basic plot using the following code. A more elaborate version is
shown in Figure \ref{fig:owl-plot-fancy}. 

<<owl-plot-basic, echo=TRUE, eval=FALSE>>=
ggplot(snow, aes(X, Y)) + geom_point(aes(colour = nao_effect))
@

Overall, we find a weak average positive effect of annual mean NAO on overall
counts, but a southeast to northwest gradient in the intensity of the effect
(Figure \ref{fig:owl-plot-fancy}). This result is consistent with owls closest
to the Atlantic coast and those migrating the furthest south being the most
affected by NAO. 

<!-- TODO keep this? -->
<!-- We provide an extended version of this example in Appendix \ref{app:owls}. -->

<<shapes, echo=FALSE>>=
if (!file.exists(here::here("data/ne_10m_lakes"))) {
  zip_file <- paste0("https://www.naturalearthdata.com/http//www.naturalearthdata.com/",
    "download/10m/physical/ne_10m_lakes.zip")
  download.file(zip_file, destfile = here::here("data/ne_10m_lakes.zip"))
  unzip(here::here("data/ne_10m_lakes.zip"), exdir = here::here("data/ne_10m_lakes"))
}
@

<<shapes-read, echo=FALSE>>=
Albers <- "+proj=aea +lat_0=40 +lon_0=-96 +lat_1=20 +lat_2=60 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs"
coast <- rnaturalearth::ne_coastline(scale = "medium", returnclass = "sf") %>%
  sf::st_transform(crs = Albers)
lakes <- sf::st_read(here::here("data/ne_10m_lakes"), quiet = TRUE)
lakes <- lakes[lakes$scalerank == 0, ] %>% sf::st_transform(crs = Albers)
@

<<owl-proj2>>=
# project to get nice axis limits 
snow2 <- snow |> mutate(X = X * 100000, Y = Y * 100000)
snow2 <- snow2 |> mutate(x = X, y = Y) |> 
  sf::st_as_sf(coords = c("x", "y"), crs = Albers)
@

<<owl-plot-fancy, echo=FALSE, eval=TRUE, fig.cap="Spatially varying coefficient for effect of mean annual NAO (North Atlantic Oscillation) on counts of Snowy Owls observed on annual Christmas Bird Counts from 1979--2020 in Canada and the US. Points represent all count locations and circle area is scaled to the mean number of owls observed per year (range: 0 to 8). The effect is multiplicative on owl count per NAO unit. In the west, the values are near 1 implying no effect, whereas in the southeast the effect becomes positive.", fig.width=6.5>>=
nao_effect_df <- select(snow, X, Y, nao_effect) |> distinct() |> 
  mutate(X = X * 100000, Y = Y * 100000) # to match CRS
ggplot(data = nao_effect_df) +
  geom_point(aes(X, Y, colour = nao_effect)) +
  geom_sf(data = coast, colour = "gray50") +
  geom_sf(data = lakes, colour = "gray50", fill = NA) +
  coord_sf(
    xlim = c(min(snow2$X), max(snow2$X)),
    ylim = c(min(snow2$Y), max(snow2$Y))
  ) +
   scale_colour_viridis_c(
    guide = guide_colourbar(direction = "horizontal", title.position = "left")
  ) +
  labs(colour = "Estimated multiplicative effect\nof NAO on Snowy Owl count") +
    theme(legend.position = "bottom", axis.title = element_blank())
@

\clearpage

<!-- The latter `tidy()` call returns all variance components of the model and omits the standard errors since these are calculated in log space. -->

<!-- We can run some basic checks on our model with the `sanity()` function: -->

<!-- We can make predictions with the `predict()` method (`?predict.sdmTMB`) and optionally use the `newdata` argument to predict on a new data frame with any locations and values for the predictor columns. -->
<!-- Here, we will predict on a 2 $\times$ 2 km grid (`qcs_grid`) that covers the entire region of interest so we can visualize the predictions spatially. -->
<!-- The grid contains spatial covariate columns and all predictors used in the model set at values for which we want to predict. -->

<!-- \begin{figure} -->
<!-- \centering -->
<!-- \includegraphics[width=5.2in]{../../figs/pcod-fig} -->
<!-- \caption[]{Output from the Pacific Cod spatial model example in Queen Charlotte Sound, BC, Canada. -->
<!-- (A) SPDE mesh (lines) combined with the trawl survey observations (points). Finer meshes will be slower to fit but generally increase the accuracy of the SPDE approximation. The circle area corresponds to biomass density of Pacific Cod caught on individual trawls. -->
<!-- (B) Spatial random field: these values are shown in link (log) space and represent spatially correlated deviations that are not accounted for by the depth effect. (C) Overall prediction: these estimates represent the combination of all fixed and random effects. Crosses illustrate center of gravity (\texttt{get\_cog()}) from a spatiotemporal version; lighter crosses are more recent. -->
<!-- (D) Conditional effect of depth modelled as a penalized smoother. -->
<!-- These predictions are made omitting the spatial random field. -->
<!-- (E) Standardized area-weighted population index derived from a spatiotemporal version (\texttt{get\_index()}). The line represents the estimate and the ribbon indicates a 95\% confidence interval ($\pm$ 2 SEs).}\label{fig:pcod-fig} -->
<!-- \end{figure} -->

<!-- We could extend this to a spatiotemporal model simply by supplying the year column name to the `time` argument (`time = "year"`) and specifying how we want the spatiotemporal random fields to be structured. -->
<!-- Here, we will keep the spatial field (`spatial = "on"`), structure the spatiotemporal random fields as independent (`spatiotemporal = "iid"`), include a time-varying intercept (`~ 1`) fit as a random walk process (`time_varying_type = "rw"`), include anisotropy to allow spatial correlation to decay at different rates up the coast vs.\ away from the coast (`anisotropy = TRUE`), and use `silent = FALSE` to see model fitting progress. -->

\clearpage

# Discussion

How does one choose among the related packages mentioned in this paper to fit SPDE-based geostatistical GLMMs?
Assuming a given package can fit the model of interest (Table  &nbsp;\ref{tab:functionality}), we suggest the primary differences are the user interface (Appendix \ref{app:inla}) and speed.
We think users familiar with `stats::glm()`, \pkg{lme4}, \pkg{mgcv}, or \pkg{glmmTMB} will find \pkg{sdmTMB} most approachable.
Users familiar with \proglang{R}-\pkg{INLA} will find \pkg{inlabru} approachable.
Users familiar with \pkg{mgcv} can adapt \pkg{mgcv} to fit similar models with custom code [@miller2019] and \proglang{R}-\pkg{INLA}/\pkg{inlabru} and \pkg{mgcv} are also general purpose modelling packages.
\pkg{VAST} is the sole option for fitting some multivariate models;
alternatively, because \pkg{VAST} focuses on multivariate delta models and fisheries applications, users fitting "simple" univariate spatial/spatiotemporal GLMMs in non-fisheries contexts may find \pkg{sdmTMB} more straightforward.
Users looking for calculation, with uncertainty, of derived variables such as area-weighted population indexes, may favour \pkg{sdmTMB} or \pkg{VAST} (although such quantities can be post hoc derived with other packages).
<!-- Speed-wise, the TMB-based packages \pkg{sdmTMB} and \pkg{VAST} were fastest up to at least 1000 mesh nodes, which in practice can cover fairly complex spatial processes on large datasets [e.g., @anderson2019b; @maureaud2021; @english2022]. -->


With respect to computational speed, \pkg{sdmTMB} (and due to having the same \pkg{TMB} backend, \pkg{VAST}) were fastest with a spatial model up to at least \textasciitilde 1000 mesh vertices at approximately a seven-times (at 1165 vertices) to 30-times (at 125 vertices) speed increase over \proglang{R}-\pkg{INLA}/\pkg{inlabru}.
These speed increases can allow for more rapid and thorough model exploration and experimentation with a class of computationally intensive models.
However, for users ultimately interested in Bayesian inference, the approximate Bayesian inference offered by \proglang{R}-\pkg{INLA}/\pkg{inlabru} is likely to be considerably faster than passing the same model from \pkg{sdmTMB}/\pkg{VAST} to \pkg{tmbstan} for full Bayesian inference.
<!-- Furthermore, although both \proglang{R}-\pkg{INLA}/\pkg{inlabru} and \pkg{sdmTMB} can use parallel processing, the PARDISO library [@pardiso-7.2c] within \proglang{R}-\pkg{INLA}/\pkg{inlabru} allows memory to be shared across cores. -->

<!-- However, with the SPDE, \pkg{mgcv} is typically slower than \pkg{sdmTMB} for similar models without optimized matrix libraries and lacks certain  -->

<!--
There are many \proglang{R} packages available for fitting spatially explicit models to large datasets and we cannot review them all here [see @heaton2019]; however, the three most closely related are \pkg{VAST}, \pkg{inlabru}, and \pkg{mgcv} (Table 1).
\pkg{VAST} is also built on \pkg{TMB} and, for univariate data, should be able to fit equivalent models with some minor differences in the user interfaces.
Interface-wise, \pkg{VAST} is less modular (e.g., by default constructing meshes before fitting, making predictions at the same time as fitting), is written from a fisheries perspective, and lacks some interface elements that we think make \pkg{sdmTMB} more broadly usable by applied ecologists.
For example, `sdmTMB()` has a `family` argument as in `glm()`, a `predict()` method, and human-readable options for spatial/spatiotemporal fields (e.g., `spatial = 'on'`, `spatiotemporal = 'AR1'`).
From a fisheries perspective, \pkg{sdmTMB} achieves three of the four design principles outlined in @thorson2019 for index standardization: it allows area weighting, can distinguish catchability and habitat covariates (by deciding what is fixed when predicting), and conditions on missing covariates (random fields).
Unlike \pkg{VAST}, however, \pkg{sdmTMB} does not currently extend to multivariate applications or support delta/hurdle models.

\pkg{inlabru} is similar to \pkg{sdmTMB} in design, but differs fundamentally in that fitting is achieved via \proglang{R}-\pkg{INLA} and approximate Bayesian computation.
For some models, TMB/\pkg{sdmTMB} can be considerably faster than \proglang{R}-\pkg{INLA}/\pkg{inlabru}, but those differences depend on the SPDE mesh, model, algebra libraries, and fitting algorithm settings [Figure \@ref(fig:timing), @osgood-zimmerman2021].
One major capability included in \pkg{sdmTMB} but not \proglang{R}-\pkg{INLA}/\pkg{inlabru} is anisotropy.
Furthermore, we think the \pkg{sdmTMB} interface will be more familiar than \pkg{inlabru} to users of `glm()`, \pkg{lme4}, \pkg{mgcv}, or \pkg{glmmTMB}.
On the other hand, \pkg{inlabru} fits additional model classes including log Gaussian Cox processes and may be particularly usable to those already familiar with \proglang{R}-\pkg{INLA}.

\pkg{mgcv} can fit many similar models to \pkg{sdmTMB} either with various flavours of splines or even with the SPDE approximation to random fields [@miller2019]; however, there are some notable advantages of \pkg{sdmTMB} for the specific class of models discussed here.
First, the smoothers typically used with \pkg{mgcv} (e.g., thin plate splines), while capable of making equivalent predictions [@miller2019; @pedersen2019], do not offer the ecological interpretability of a spatially explicit random field model (spatial range and variance estimates).
Second, the implementation of the Tweedie distribution in \pkg{mgcv} requires the power parameter to be fixed in a mixed effects model.
Third, \pkg{mgcv} does not have built-in functionality to calculate derived values with uncertainty such as population indexes or center of gravity.
Despite these \pkg{sdmTMB} advantages for the models discussed here, \pkg{mgcv} is an immensely powerful modelling package that extends well beyond spatial random field models.
-->

<!-- MVT? time-varying epsilon, non-gaussian fields -->
<!-- 3d models, continuous time, -->

Additional functionality in \pkg{sdmTMB} not already mentioned includes interpolating across missing time slices and forecasting, the barrier SPDE model [@bakka2019], time-varying spatiotemporal covariance parameters [@ward2022], and simulation from the parameter joint precision matrix.
Future development may include additional zero-inflated models, improvements to Bayesian sampling efficiency [e.g., @monnahan2021], continuous-time models [e.g., @blangiardo2015book], multivariate responses, and non-Gaussian random fields [e.g., @anderson2019].
The included \pkg{TMB} `.cpp` file provides a tested model template that can be modified to add additional features.

There are a number of planned additions to the sdmTMB model structure. A subset of features to be added in the near future includes (1) multivariate models to allow for simultaneous modeling of data from multiple species, (2) integration with the RTMB package so that the model code base will be written in R rather than C++, (3) inclusion of a dispersion formula similar to \pkg{glmmTMB} [@brooks2017], and (4) estimation of random slopes. 

<!-- TODO: RTMB -->
<!-- TODO: multivariate -->

# Acknowledgements

\pkg{sdmTMB} would not be possible without the \pkg{TMB} [@kristensen2016] and \proglang{R}-\pkg{INLA} [@rue2009; @lindgren2011; @lindgren2015] \proglang{R} packages.
\pkg{sdmTMB} is heavily inspired by and in some places code has been adapted from both the \pkg{VAST} [@thorson2019] and \pkg{glmmTMB} [@brooks2017] \proglang{R} packages (as described in the DESCRIPTION and inst/COPYRIGHTS files).
Smoother support was possible thanks to \pkg{mgcv} [@wood2017a].
We thank the authors of all these packages.
We thank S. Kotwicki, M. Lindmark, M. Martin, C.C. Monnahan, P.M. Regular, J.T. Thorson, and J. Watson for helpful comments that substantially improved the manuscript.
Christmas Bird Count data were provided by National Audubon Society and through the generous efforts of Bird Studies Canada and countless volunteers across the Western Hemisphere.
<!-- TODO: thank reviewers -->

\clearpage

\appendix

<<child="pcod.Rmd", eval=FALSE, cache=TRUE>>=
@

<<child="owls.Rmd", eval=FALSE, cache=TRUE>>=
@

<<child="inla-comparison.Rmd", eval=FALSE, cache=TRUE>>=
@

<<child="timing.Rmd", eval=FALSE, cache=TRUE>>=
@
